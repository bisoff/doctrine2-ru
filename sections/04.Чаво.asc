= Часто задаваемые вопросы

Этот раздел постоянно пополняется. От вас приходит много вопросов, на многие из них мы не отвечаем, но помним о чем спрашивают чаще всего. Если у вас есть вопрос, подписывайтесь на рассылку или подключайтесь в _IRC_ к каналу _#doctrine_.

=== 4.1. Схема базы данных

==== 4.1.1. Как установить кодировку и COLLATION для таблиц MySQL?

Кодировку нельзя установить через аннотации и файлы XML- или YAML- отображений. Для настройки базы на работу с определенной кодировкой нужно установить ее как кодировку по-умолчанию в конфигурации MySQL, либо указать эти параметры при создании таблиц. В этом случае они будут автоматически применяться ко всем создаваемым таблицам и столбцам.

=== 4.2. Классы сущностей

==== 4.2.1. Обращаюсь к переменной-члену, а мне возвращается значение NULL, что не так?

Похоже вы объявили переменную как публичную (public), тем самым нарушив одно из ограничений, накладываемых на сущности. Для корректной работы объектов прокси хранимые переменные-члены у сущности должны быть объявлены как приватные или защищенные.

==== 4.2.2. Как добавить для столбца значение по умолчанию?

_Doctrine_ не поддерживает установку значений по умолчанию для столбцов как это делает в язык SQL через ключевое слово_DEFAULT_. Однако, это и не нужно, просто используйте для этого языковыми конструкции PHP:
----
class User  
{  
    const STATUS_DISABLED = 0;  
    const STATUS_ENABLED = 1;  

    private $algorithm = "sha1";  
    private $status = self:STATUS_DISABLED;  
}
----

=== 4.3. Отображения

==== 4.3.1. При выполнении $em->flush() появляются ошибки, связанные с нарушением уникальности данных

_Doctrine_ не проверяет не добавляете ли вы в базу данных сущности с уже дублирующимися ключами _PRIMARY_, или не добавляете ли вы дважды  в коллекцию одну и ту же сущность. Если есть какие-то опасения на этот счет, всегда можно сделать соответствующую проверку перед вызовом _$em->flush()_.

В http://www.symfony.com/[Symfony2] для этого существует соответствующий компонент под названием _Unique Entity Validato_r.

Проверить содержит ли коллекция заданную сущность можно с помощью метода _$collection->contains($entity)_. Для коллекции с параметром _FETCH_ равным _LAZY_ этот метод просто инициализирует коллекцию, однако если _FETCH_ равен _EXTRA_LAZY_, то для проверки принадлежности Doctrine выполнит _SQL_-запросы.

=== 4.4. Связи

==== 4.4.1. Мне выдается исключение InvalidArgumentException  с сообщением “A new entity was found through the relationship..”. Что не так?

Это исключение выбрасывается при исполнении метода _EntityManager#flush()_ в случае, если в общей схеме данных существует объект, содержащий ссылку на некоторый объект, неизвестный _Doctrine_. Чтобы было проще понять, представьте, например, что вы загрузили из базы данных сущность пользователя _(User)_ со своим идентификатором, затем создали новый объект и привязали его к объекту _User_ через одну из существующих у него взаимосвязей. Затем, если вы вызовете_EntityManager#flush()_, не сообщив об свежесозданном объекте _Doctrine_ с помощью метода _EntityManager#persist($newObject)_, будет выброшено такое исключение.

Решить проблему можно двумя путями:

1.  Предварительно вызвать метод _EntityManager#persist($newObject)_ для вновь созданного объекта
2.  Использовать свойство _cascade=persist_ для связи, содержащей новый объект

==== 4.4.2. Могу ли я как-то отфильтровать связанный с сущностью набор данных?

Такой возможности нет ни в версии_ Doctrine 2.0_, ни в _2.1_. Для фильтрации набора сущностей лучше использовать возможности DQL.

==== 4.4.3. После вызова метода clear() на наборе типа “один ко многим”, сущности почему-то не были удалены

Это ожидаемое поведение, связанное с концепции обратной и владеющей сторон связи, и тем, как с ними работает движок_Doctrine_. Когда сторона взаимосвязи “один ко многим” объявляется обратной, это означает, что Doctrine перестает воспринимать все изменения сущности, внесенные по эту сторону связи.

В качестве замены методу clear() можно использовать перебор по коллекции и установить ссылку на владеющей стороне отношения “многие к одному” в _NULL_, тем самым все сущности будут выброшены из коллекции. После этого будут выполнены соответствующие UPDATE запросы к базе данных .

==== 4.4.4. Как добавить дополнительные столбцы к связи вида “один ко многим”?

В качестве столбцов в определении таблицы для связи “один ко многим” допускается использовать только внешние ключи. Для добавления в такие связи дополнительных столбцов есть возможность использования внешних ключей как первичных (primary). Такая фича появилась в _Doctrine 2.1_.

Как это сделать читайте в http://www.doctrine-project.org/docs/orm/2.1/en/tutorials/composite-primary-keys.html[обучалке по составным первичным ключам].

==== 4.4.5. Можно ли осуществлять постраничную выборку из присоединенных коллекций?

Если вам нужно выражение DQL, которое может это сделать, мы вас огорчим, нет простого способа итерации по такой коллекции с помощью оператора LIMIT.

_Doctrine_ не предоставляет решения “из коробки”, однако существует несколько расширений, позволяющих это сделать:

1.  http://github.com/beberlei/DoctrineExtensions[DoctrineExtensions]
2.  http://github.com/whiteoctober/pagerfanta[Pagerfanta]

==== 4.4.6. Почему постраничная выборка некорректно работает с соединениями (fetch-joins)?

Для ограничения результирующего набора данных движок постраничной выборки в _Doctrine_ использует ключевое слово_LIMIT_ (или его эквивалент). Однако, когда вы выполняете JOIN запрос, он не возвращает верное число записей, т.к. соединения через связи вида “один ко многим” и “многие ко многим” в качестве результирующего количества строк возвращают произведение числа строк на число связанных сущностей.

> Примечание переводчика: простите, слишком сложно перевести. Оригинал:  
> Pagination in Doctrine uses a LIMIT clause (or vendor equivalent) to restrict the results. However when fetch-joining this is not returning the correct number of results since joining with a one-to-many or many-to-many association muliplies the number of rows by the number of associated entities.

Для решения проблемы смотрите предыдущий вопрос .

=== 4.5. Наследование

==== 4.5.1. Можно ли применять наследование в Doctrine 2?

Да, допускается наследование применительно как к единичным, так и присоединенным таблицам.

Детали описаны в соответствующей главе.

==== 4.5.2. Почему Doctrine не создает прокси объекты для иерархии классов?

Когда в сущности создается связь с родительским классом вида “многие к одному” или “один к одному”, _Doctrine_ не может определить какой из классов в действительности выступает в качестве “внешнего ключа”. Чтобы выяснить это, _Doctrine_ должна выполнить _SQL_ запрос для поиска этой информации в базе данных.

=== 4.6. EntityGenerator

==== 4.6.1. Почему EntityGenerator не делает ту или иную вещь?

_EntityGenerator_ не является полноценным генератором кода, решающим любые задачи. Генерация кода отныне не является основным приоритетом _Doctrine 2_ (в отличие от _Doctrine 1_). _EntityGenerator_ конечно помогает в работе, но это не панацея.

== 4.6.2. Почему EntityGenerator некорректно работает с иерархиями?

Дело в том, что _EntityGenerator_ не может правильно угадать взаимоотношения в иерархии классов. Вот почему создание наследуемых сущностей затруднено и пока не работает как нужно. Обрабатывать подобные ситуации вам нужно будет вручную.

=== 4.7. Производительность

==== 4.7.1. Почему когда я обращаюсь к данным через отношение “один к одному” это всякий раз порождает SQL запрос?

Если _Doctrine_ обнаружила, что обращение к данным происходит с обратной стороны связи (inverse side), то для загрузки целевого объекта будет выполнен дополнительный запрос. Так происходит потому что нельзя определить, вдруг там вообще нет никакого объекта (стоит NULL), или там прокси-объект, а какой у него идентификатор одному богу известно.

Чтобы избежать этой проблемы, используйте запрос который сразу получает всю необходимую информацию.

=== 4.8. Язык DQL

==== 4.8.1. Что представляет собой DQL?

_DQL_ это язык, очень похожий на _SQL_, имеющий ряд особенностей:

1.  Вместо названия таблиц и столбцов он использует названия классов и их полей, абстрагируясь между бэкендом и объектной моделью.
2.  _DQL_ применяет информацию, хранящуюся в метаданных, давая возможность использовать сокращения при написании запросов. Например, если вы не указали оператор _ON_ при соединении таблиц _Doctrine_ сделает это за вас.
3.  _DQL_ добавляет некоторую функциональность, связанную с управлением объектами и преобразованием их в запросы_SQL_.

Конечно, есть и недостатки:

1.  Синтаксис его немного отличается от _SQL_, поэтому нужно четко уяснить различия.
2.  Чтобы не зависеть от особенностей каждой конкретной СУБД, _DQL_ реализует лишь общее подмножество _SQL_, поддерживаемое всеми продуктами.
3.  В DQL нельзя использовать специфичный для конкретной СУБД функционал и различные оптимизации, пока они в явном виде не будет реализованы вами.
4.  Для некоторых конструкций в _DQL_ применяются вложенные _SELECT’ы_, которые в том же _MySQL_ работают медленно.

==== 4.8.2. Можно ли в DQL выполнить сортировку по заданной функции (например, ORDER BY RAND())?

Нет. Если вам нужен такой функционал, используйте низкоуровневые запросы или ищите другое решение. Имейте ввиду: начиная с 1000 записей в таблице сортировка вида _ORDER BY RAND()_ выполняется крайне медленно.