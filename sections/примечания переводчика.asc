anchor:aa[]

=== Примечания переводчика ===

Когда я работал над переводом, в тексте основных глав документации по Doctrine мне неоднократно встречались термины, значение которых понятны лишь в контексте ORM, трактовать их можно по-разному. При прямом переводе без пояснений их смысл может быть утерян. Поэтому в этом разделе я просто своими словами опишу, что по моему мнению они означают, чтобы вам было понятно о чем будет идти речь и не возникло проблем при чтении руководства.

*Entity, Persistent classes*

Сущность, хранимый (персистентный) класс. По сути одно и тоже. Основная концепция Doctrine. Сущностью может быть одна таблица, либо таблица со связанными с ней другими таблицами. Да что там, сущностью может быть целая база данных! Чтобы класс считался хранимым (то есть обрабатывался Доктриной) он должен быть помечен как сущность при помощи метаданных, например аннотацией к классу со свойством @Entity:
----
/** @Entity */
class Entity_MyItem
{
}
----
*Metadata, Оbject-relational mapping metadata*
Метаданные. Набор параметров, описывающих как объектная модель будет проецироваться на физическую модель в базе данных. Эти директивы превращают обычный класс в сущность. Вы берете обычный класс, добавляете к нему метаданные и все — вот она ваша сущность. Метаданные могут быть определены тремя strong textспособами:

* XML
* YAML
* Аннотации DocBlock (комментарии в PHP-коде)

*Association*

Ассоциация. Взаимосвязь. Связь. Отношение. У сущности кроме простых полей могут быть поля, олицетворяющие ее взаимосвязь с другими сущностями. Что-то вроде отношений в базах данных (собственно это они и есть, но покрытые слоем абстракции ORM). Я предпочитаю называть это просто связью. Это соединения между сущностями.

*Inverse/owning side*

Владеющая (прямая) и обратная стороны связи. Что это значит? К примеру, у вас есть сущность “Новость” и есть сущность “Комментарий”. У одной новости может быть несколько комментариев, поэтому комментарий содержит в себе ссылку на новость (физически в базе данных есть соответствующее поле, вроде new_id). Как вы видите, это классический пример отношения “один ко многим”, где “один” это новость, а “многие” это комментарии. Комментарии однозначно связаны с новостью, поэтому они — сторона владельца или прямая сторона. Это позволяет из сущности комментария перейти к сущности новости. Обратная сторона связи позволяет из новости получить указатель на ее комментарии.

*Proxy classes*

Классы прокси. Прокси. Классы-заглушки. Используются для ускорения.

*Persistent properties*

Хранимые свойства. Хранимые члены. Свойства класса сущности, непосредственно имеющие отношения к базе данных. Именно они и олицетворяют сущность как таковую. Такие свойства помечены соответствующими тегами в аннотациях к ним.

*DiscriminatorColumn*

Столбец дискриминатора. Столбец дискриминатора содержит значение, которое определяет, какому классу принадлежит каждая запись. Что это такое? Это пошло еще с Java Hibernate.

Например, рассмотрим таблицу Persons, которая содержит данные всех сотрудников компании. Некоторые лица являются служащими, а некоторые — менеджерами. Таблица Persons содержит столбец с именем EmployeeType, который имеет значение 1 для менеджеров и значение 2 для служащих; это и есть столбец дискриминатора. В этом случае можно создать подкласс служащих и заполнить класс только записями, которые имеют в столбце EmployeeType значение 2. Кроме того, можно удалить из каждого класса неприменимые столбцы.

*Schema-Tool*

Инструмент для работы со схемой данных. Он перестраивает ее, удаляет, создает. Переводить не нужно.

*Mapping*

Отображение. Соответствия. Основная концепция любой ORM. Отображение объектной структуры на модель базы данных.

*Hydration*

Гидрация. Вменяемого перевода на русский нет. Процесс гидрации – это процедура преобразования результата SQL запроса в объектную модель. В этот момент создаются экземпляры сущностей, подключаются связи и так далее.

*Annotations*

Аннотации.

*Metadata drivers*

Драйвер метаданных. Управляют различными способами представления метаданных (XML, YAML, аннотации Dockblock).

*Metadata Cache*

Кеш метаданных. Чтобы каждый раз не парсить метаданные.

*Query cache*

Кеш запросов. Не то, что вы подумали. Он кеширует не результаты SQL запросов, а результат разбора запроса DQL.

*Collection*

Коллекция, список. Используется в контексте отношений “один ко многим” и “многие ко многим”. Похожи на массив, но конечно более навороченная концепция.

*DQL*

Язык запросов Doctrine. Чем-то похож на SQL. Не вижу смысла переводить аббревиатуру.

*Orphan removal*

Переводится как “удаление объектов-сирот”. Технология каскадного удаления объектов, на которые потеряны ссылки. Пример с новостями и комментариями: комментарий связан с новостью, при удалении новости сам комментарий перестает иметь смысл (конечно если вы не решите иначе). Так вот данный подход позволяет удалить его автоматически, если связь содержащая такой комментарий была соответствующим образом настроена.

*Ass*

Некоторые предложения по тексту глав вызывали именно такое определение, по этой причине я не смог их перевести, не обессудьте.
