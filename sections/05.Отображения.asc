= Отображения

В главе приведено описание механизма отображений объектов и их свойств на структуру базы данных. Отображение для связей будет описано в следующей главе.

=== 5.1. Драйвера отображений

Любые отображения в Doctrine задаются через метаданные. Существует несколько способов для описания метаданных:

1.  Аннотации Docblock
2.  XML
3.  YAML
В примерах к данному руководству в основном будут использоваться аннотации _Dockblock_, однако во многих из них приведены и альтернативы на _XML_ и _YAML_. Более детальному описанию отображений через _XML_ и _YAML_ посвящены отдельные главы. Кроме того, отдельная глава будет посвящена синтаксису аннотаций.

> Если вас беспокоит вопрос, какой же из описанных механизмов имеет лучшую производительность, вот ответ: все они одинаково быстро работают. После того как метаданные считаны из источника (_XML_, _YAML_ или аннотаций) они тут же сохраняются в экземпляре класса Doctrine\ORM\Mapping\ClassMetadata, который, в свою очередь, хранится в специальном кеше для метаданных. Так что в итоге все они будут выполняться одинаково быстро. Если вы все же решите отказаться от кеша метаданных (что делать крайне не рекомендуется), то преимущество будет у драйвера XML, т.к. разбор этого формата осуществляется напрямую библиотекой PHP.

=== 5.2. Аннотации Docblock

Вы, наверное, уже сталкивались с _Dockblock_ аннотациями, например, когда готовили метаданные для утилит вроде_PHPDocumentor_ (_@author_, _@link_, …). С их помощью в документацию можно встроить некоторые метаданные, а затем использовать их в своих целях. _Dockblock_ аннотации работают также._ Doctrine 2_ обобщает концепцию аннотаций, так что их можно использовать для определения любых типов метаданных, а это позволяет определять новые аннотации. Для более эффективного использования и уменьшения вероятности их конфликта имен, в Doctrine 2 для аннотаций  используется альтернативный синтаксис, чем-то напоминающий аннотации в Java 5.

Собственно сама реализация Dockblock аннотаций заложена в пространстве имен _Doctrine\Common\Annotations_, относящуюся к пакету _Common_. Среди прочего, в _Dockblock_ можно использовать пространства имен, а также вложенные аннотации. Вы все увидите в примерах. Doctrine 2 для задания метаданных, описывающих отображения, использует собственное подмножество директив.

Если вас по каким-то причинам не устраивают Dockblock аннотации, в качестве альтернативы могут быть использованы XML или YAML. Вы даже можете написать свой собственный механизм для работы с метаданными.

=== 5.3. Хранимые классы

Итак, сущность это класс. Чтобы подготовить класс для работы в среде _ORM_, его необходимо превратить в сущность. Это делается с помощью специальной аннотации _@Entity_:

*PHP*

----
<?php  
/** @Entity */  
class MyPersistentClass  
{  
    //...  
}
----

*XML*

----
<doctrine-mapping>  
    <entity name="MyPersistentClass">  
        <!-- ... -->  
    </entity>  
</doctrine-mapping>
----

*YAML*
----
MyPersistentClass:  
    type: entity  
    # ...
----

По умолчанию сущность будет преобразована в таблицу БД, имя которой соответствует имени класса сущности. Если вы хотите задать иное имя, можно воспользоваться аннотацией _@Table_:

*PHP*
----
<?php  
/**  
* @Entity  
* @Table(name="my_persistent_class")  
*/  
class MyPersistentClass  
{  
    //...  
}
----

*XML*
----
<doctrine-mapping>  
    <entity name="MyPersistentClass" table="my_persistent_class">  
        <!-- ... -->  
    </entity>  
</doctrine-mapping>
----

*YAML*
----
MyPersistentClass:  
    type: entity  
    table: my_persistent_class  
    # ...
----

В этом примере экземпляр сущности _MyPersistentClass_ будет храниться в базе данных в виде таблицы с именем_my_persistent_class_.

=== 5.4. Отображения типов в Doctrine

В _Doctrine_ можно устанавливать соответствия между типами _PHP_ и соответствующим им типам в базе данных. Все отображаемые типы, поставляемые с _Doctrine_, полностью совместимы с различными СУБД. Как будет показано далее в этой главе, можно создавать и пользовательские типы, совместимость которых, однако, уже не гарантируется.

Например, тип Doctrine **string** устанавливает соответствие между типом _string_ в _PHP_ и типом _VARCHAR_ (или _VARCHAR2_, в зависимости от СУБД). Ниже приведено краткое описание доступных типов:
----
**string**: Отображает _VARCHAR_ в строку _PHP_.  
**integer**: Отображает _INT_ на целочисленный тип.  
**smallint**: Отображает _SMALLINT_ так же на целочисленный тип в _PHP_.  
**bigint**: Отображает _BIGINT_ на строку _PHP_.  
**boolean**: Отображает булевый тип (в _MySQL_ это_ TINYINT(1))_ на булевый тип в _PHP_.  
**decimal**: Отображает _DECIMAL_ на тип _double_.  
**date**: Отображает _DATETIME_ на объект типа _DateTime_.  
**time**:  Отображает _TIME_ также на объект типа _DateTime_.  
**datetime**: Отображает типы _DATETIME_ или _TIMESTAMP_  на объект _DateTime_ в _PHP_.  
**text**: Отображает тип _CLOB_ на строку _PHP_.  
**object**: Отображает тип _CLOB_ на объект _PHP_ с помощью сериализации (_serialize()_ и _unserialize())_  
**array**:  Отображает тип _CLOB_ на объект _PHP_ с помощью сериализации (_serialize()_ и _unserialize())_  
**float**: Отображает тип _FLOAT_ (двойной точности) на тип _double_ в _PHP_. **Важно**: Отображение работает только с настройками локали, в которых в качестве десятичного разделителя используется точка.
----

> Запомните, отображаемые типы в _Doctrine_ не являются ни _SQL_- ни _PHP_-типами! Они лишь устанавливают соответствие между этим двумя типами данных. Кроме того, они зависимы от регистра. Например, _DateTime_ это не одно и тоже что _datetime_, который уже входит в комплект _Doctrine_.

> Типы _DateTime_ и _Object_ всегда сравниваются по ссылке, а не по значению. Обновление их значений будет происходить в случае, если изменилась сама ссылка, поэтому объекты этих типов ведут себя подобно объектам, значение которых не может быть изменено.

При работе с типами даты и времени предполагается, что используется стандартная временная зона, установленная функцией http://docs.php.net/manual/en/function.date-default-timezone-set.php[date_default_timezone_set()] или через параметр _date.timezone_ в _php.ini_. При использовании в приложении различных временных зон результат может быть непредсказуемым.

Если в вашем приложении все же требуется какая-то специальная обработка временных зон, то нужно делать это вручную, перегоняя значения даты в _UTC_ и обратно. В руководстве есть http://www.doctrine-project.org/docs/orm/2.1/en/cookbook/working-with-datetime.html[соответствующая статья], в которой описана работа с типами даты и времени при использовании различных временных зон.

= 5.5. Сопоставление свойств

После того как класс стал сущностью, можно начать устанавливать отображения для его отдельных членов. Ниже буду описаны лишь самые простые поля со скалярными типами, вроде целых чисел и строк. Связи с другими объектами описываются в главе “Отображения связей”.

Свойство может быть отмечено как хранимое с помощью аннотации _@Column_. Эта аннотация требует указания как минимум одного атрибута -- типа столбца, в качестве которого можно использовать любой из доступных типов _Doctrine_. Если опустить этот параметр, в качестве типа будет использован _string_, ведь он самый гибкий и универсальный.

Пример:

PHP
<?php  
/** @Entity */  
class MyPersistentClass  
{  
    /** @Column(type="integer") */  
    private $id;  
    /** @Column(length=50) */  
    private $name; // type defaults to string  
    //...  
}
XML
<doctrine-mapping>  
    <entity name="MyPersistentClass">  
        <field name="id" type="integer" />  
        <field name="name" length="50" />  
    </entity>  
</doctrine-mapping>
YAML
MyPersistentClass:  
    type: entity  
    fields:  
        id:  
            type: integer  
        name:  
            length: 50
В этом примере полю _id_ соответствует столбец _id_ целочисленного типа, а полю name -- столбец _name_ и тип _string_, используемый по умолчанию. Как видите, по умолчанию именам столбцов будут присвоены такие же имена, как и у полей. Задать столбцу иное имя можно с помощью атрибута _name_:

PHP
<?php  
/** @Column(name="db_name") */  
private $name;
XML
<doctrine-mapping>  
    <entity name="MyPersistentClass">  
        <field name="name" column="db_name" />  
    </entity>  
</doctrine-mapping>
YAML
MyPersistentClass:  
    type: entity  
    fields:  
        name:  
            length: 50  
            column: db_name
Для более тонкой настройки отображений на столбцы БД можно использовать атрибуты. Вот их полный список:

**type**: (необязательный параметр, значение по умолчанию: ‘string’) Отображаемый тип для столбца.  
**name**: (необязательный параметр, по умолчанию соответствует имени свойства) Название столбца в базе данных.  
**length**: (необязательный параметр, по умолчанию равен 255) Длина значения столбца в базе данных. (Применяется только для строковых типов).  
**unique**: (необязательный параметр, по умолчанию равен _FALSE_) Определяет, являются ли значения столбца уникальными.  
**nullable**: (необязательный параметр, по умолчанию равен _FALSE_) Могут ли значения столбца принимать пустые значения_(NULL)_.  
**precision**: (необязательный параметр, по умолчанию равен 0) Точность для неупакованных чисел с плавающей точкой. (Применяется только для столбцов типа DECIMAL.)  
**scale**:  (необязательный параметр, по-умолчанию равен 0) Задает шкалу (scale) для неупакованных чисел с плавающей точкой. (Применяется только для столбцов типа _DECIMAL_.)

= 5.6. Пользовательские типы

В _Doctrine_ можно создавать свои собственные отображаемые типы. Это бывает полезно, когда не удается найти подходящий тип для конкретной задачи или вас по каким-то причинам не устраивает поведение существующих типов.

Для создания нового типа нужно наследовать класс _Doctrine\DBAL\Types\Type_ и переопределить нужные вам методы. Ниже приведет шаблон такого типа:
<?php  
namespace My\Project\Types;  

use Doctrine\DBAL\Types\Type;  
use Doctrine\DBAL\Platforms\AbstractPlatform;  

/**  
 * Мой тип datatype.  
*/  
class MyType extends Type  
{  
    const MYTYPE = 'mytype'; // modify to match your type name  

    public function getSqlDeclaration(array $fieldDeclaration, AbstractPlatform $platform)  
    {  
     // Возвращает SQL, используемый для создания столбца. Если нужен совместимый тип, используйте параметр $platform.  
    }  

    public function convertToPHPValue($value, AbstractPlatform $platform)  
    {  
     // Вызывается во время чтения значения из БД. Тут можно делать разные преобразования, в т.ч. основываясь на параметре $platform.  
    }  

    public function convertToDatabaseValue($value, AbstractPlatform $platform)  
    {  
     //  Вызывается во время записи значения в БД . Тут также можно делать разные преобразования, в т.ч. основываясь на параметре $platform .  
    }  

    public function getName()  
    {  
         return self::MYTYPE; // возвращает имя типа  
    }  
}
Имейте ввиду, у этой схемы есть ограничения:

Если свойство принимает значение _NULL_, метод _convertToDatabaseValue()_ не будет вызываться.  
Модуль _UnitOfWork_ никогда не осуществляет конвертацию значений в базу данных, которые не изменились в запросе.

После того как вы реализуете свой тип, нужно сообщить о нем _Doctrine_. Это можно сделать с помощью метода_Doctrine\DBAL\Types\Type#addType($name, $className)_. Вот пример:
<?php  
// in bootstrapping code  

// ...  

use Doctrine\DBAL\Types\Type;  

// ...  

// Register my type  
Type::addType('mytype', 'My\Project\Types\MyType');
Как видно из примера, при регистрации типа ему присваивается уникальное имя на ваш выбор, которое соответствует полному имени реализующего его класса. После регистрации, тип готов к использованию:
<?php  
class MyPersistentClass  
{  
    /** @Column(type="mytype") */  
    private $field;  
}
Чтобы _Schema-Tool_ правильно смогла конвертировать ваш новый тип данных _mytype_ в экземпляр класса _MyType_, нужно будет дополнительно зарегистрировать соответствие для этих типов:
<?php  
$conn = $em->getConnection();  
$conn->getDatabasePlatform()->registerDoctrineTypeMapping('db_mytype', 'mytype');
Теперь когда _Schema-Tool_ обнаружит столбец типа _db_mytype_, она преобразует его в экземпляр класса, соответствующий доктриновскому типу _mytype_. Имейте ввиду, во избежание конфликтов каждый тип из базы данных может соответствовать только одному отображаемому типу _Doctrine_.

= 5.7. Пользовательское определение для столбца

Для любого столбца можно задать его собственное определение с помощью атрибута _columnDefinition_ аннотации _@Column_. Таким образом можно задать любое определение, следующие за именем столбца, как если бы вы это делали через SQL запрос, например, задать комментарий для столбца (и он будет сохранен в БД).

И, к сожалению, при использование этого атрибута Schema-Tool не сможет вычислять изменения в схеме базы данных.

= 5.8. Идентификаторы / Первичные ключи

Любая сущность в _Doctrine_ должна иметь свой идентификатор. Задать его можно с помощью аннотации _@Id_:

PHP
<?php  
class MyPersistentClass  
{  
    /** @Id @Column(type="integer") */  
    private $id;  
    //...  
}
XML
<doctrine-mapping>  
    <entity name="MyPersistentClass">  
          
        <field name="name" length="50" />  
    </entity>  
</doctrine-mapping>
YAML
MyPersistentClass:  
    type: entity  
    id:  
        id:  
            type: integer  
    fields:  
        name:  
            length: 50
Если не задано иное, идентификатор для новой сущности должен задаваться вручную. Это означает, что прежде чем передавать сущность методу _EntityManager#persist($entity)_ нужно установить для нее идентификатор.

В качестве альтернативы ручной установке есть возможность генерировать значения идентификатора автоматически. Это достигается использованием аннотации _@GeneratedValue_:

PHP
<?php  
class MyPersistentClass  
{  
    /**  
    * @Id @Column(type="integer")  
    * @GeneratedValue  
    */  
    private $id;  
}
XML
<doctrine-mapping>  
    <entity name="MyPersistentClass">  
          
            <generator strategy="AUTO" />  
          
        <field name="name" length="50" />  
    </entity>  
</doctrine-mapping>
YAML
MyPersistentClass:  
    type: entity  
    id:  
        id:  
            type: integer  
            generator:  
                strategy: AUTO  
    fields:  
        name:  
            length: 50
Это сообщит Doctrine, что идентификатор должен быть сгенерирован автоматически. Как именно будет происходить генерация определяется атрибутом _strategy_, по умолчанию он принимает значение _AUTO_. Это значит, что база данных сама решит как это будет происходить и использует собственный механизм. Подробности читайте далее.

== 5.8.1. Стратегии генерации идентификаторов

В предыдущем примере показано как использовать стратегию генерации идентификатора по-умолчанию, при этом не важно какая СУБД используется. Но задать эту стратегию можно и явно, это дасть возможность использовать некторые дополнительные функции.

Ниже приведен список возможных стратегий:

**AUTO** (по умолчанию): используется наиболее предпочтительная стратегия для текущей платформы БД. Для _MySQL_, _SQLite_ и_MsSQL_ это значение равно _IDENTITY_, для _Oracle_ и _PostgreSQL_ -- _SEQUENCE_ . Так что этот вариант самый универсальный.

**SEQUENCE**: Для генерации идентификатора будет использована последовательность. Эта стратегия не обеспечивает полной совместимости, т.к. поддерживается только в _Oracle_ и _PostgreSql_.

**IDENTITY**: Сообщает _Doctrine_ использовать специальные идентификационные столбцы, значение которых генерируется само при вставке новой записи в таблицу. Данный механизм поддерживается следующими платформами: _MySQL/SQLite__(AUTO_INCREMENT)_, _MSSQL_ _(IDENTITY)_ и _PostgreSQL_ _(SERIAL)_.

**TABLE**: позволяет использовать отдельную таблицу для генерации идентификаторов. Этот механизм обеспечивает полую совместимость. ***Но эта стратегия пока еще не реализована!***

**NONE**: Идентификатор не генерируется и должен быть установлен вручную. Назначать его нужно до передачи сущности методу _EntityManager#persist_. Эта стратегия будет автоматически использована при отсутствии аннотации _@GeneratedValue_.

== 5.8.1.1. Генератор последовательностей

В настоящий момент генерация последовательностей возможна только для _Oracle_ и _Postgres_. При использовании этой стратегии становятся доступны несколько новых параметров:

PHP
<?php  
class User  
{  
    /**  
    * @Id  
    * @GeneratedValue(strategy="SEQUENCE")  
    * @SequenceGenerator(sequenceName="tablename_seq", initialValue=1, allocationSize=100)  
    */  
    protected $id = null;  
}
XML
<doctrine-mapping>  
    <entity name="User">  
          
            <generator strategy="SEQUENCE" />  
            <sequence-generator sequence-name="tablename_seq" allocation-size="100" initial-value="1" />  
          
    </entity>  
</doctrine-mapping>
YAML
MyPersistentClass:  
    type: entity  
    id:  
        id:  
            type: integer  
            generator:  
                strategy: SEQUENCE  
            sequenceGenerator:  
                sequenceName: tablename_seq  
                allocationSize: 100  
                initialValue: 1
_initialValue_ задает значение, с которого начнется последовательность.

Обратите внимание на параметр _allocationSize, он_ позволяет оптимизировать производительность запросов _INSERT_. Вот как это работает. Он определяет на какое количество будет увеличенная последовательность прежде чем ее следующее значение будет физически запрошено из базы данных. Если это значение больше единицы, Doctrine будет сама генерировать идентификаторы для следующих _allocationSizes_ сущностей. В примере выше при значении _allocationSize=100_ _Doctrine_ для того, чтобы сгенерировать идентификаторы для 100 новых сущностей нужно лишь единожды обратиться к объекту _SEQUENCE_ в базе данных.

Значение по умолчанию для _allocationSize_ равно 10. _Schema-Tool_ сама обнаруживает этот параметр и преобразовывает его в конструкцию_ INCREMENT BY_ в операторе _CREATE SEQUENCE_. Если структура базы данных была создана вручную без использования _Schema-Tool_, вам нужно проследить, чтобы _allocationSize_ не превышал соответствующего ему значения в конструкции _INCREMENT BY_, иначе начнут генерироваться дубликаты. И последнее. Возможно использования параметра _strategy=”AUTO”_ совместно с _@SequenceGenerator_. В этом случае генерация последовательностей будет применяться только если есть поддержка со стороны БД (для _Oracle_ и _PostgreSQL_)

== 5.8.2. Составные ключи

_Doctrine 2_ позволяет работать с составными первичными ключами. Правда, по сравнению с единичными ключами здесь есть пара ограничений. Так, использовать аннотацию _@GeneratedValue_ можно только для простых одиночных ключей. Для составных ключей идентификатор придется генерировать вручную перед вызовом _EntityManager#persist()_.

Для создания составного ключа просто отметьте аннотацией _@Id_ все поля, из которых он состоит.

= 5.9. Экранирование ключевых слов

Иногда нужно экранировать название столбца или таблицы, если оно конфликтует с ключевыми словами той или иной СУБД. Дать понять _Doctrine_ что-именно следует экранировать можно, заключив название таблицы или столбца в обратные кавычки:
<?php  
/** @Column(name="`number`", type="integer") */  
private $number;
После этого _Doctrine_ будет будет экранировать это значение во всех _SQL_ запросах. 

Экранирование ключевых слов не работает для имен столбцов, используемых для соединений таблиц, а также в названиях столбцов-дискриминаторов.

Экранирование в основном предназначено для совместимости с устаревшими схемами данных. По возможности следует избегать подобных ситуаций. Не надо применять экранирование только потому, чтобы использовать нестандартные символы, вроде тире, в названиях столбцов. Кроме того, у _Schema-Tool_ скорее всего будут проблемы, если экранирование используется в случаях, связанных с регистрозависимостью символов (например, в Oracle).