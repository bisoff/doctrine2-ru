= Настройка

=== 3.1. Начальная загрузка

Инициализация _Doctrine_ относительно проста и осуществляется в два этапа:

1.  Убедиться, что _Doctrine_ имеет доступ ко всем небходимые классам, которые могут использоваться в процессе работы.
2.  Получить экземпляр класса _EntityManager_.

==== 3.1.1. Загрузка классов

Давайте начнем с загрузки классов. Вот что нам нужно: настроить несколько загрузчиков (часто называемых “автозагрузчиками”) таким образом, чтобы _Doctrine_ при необходимости смогла сама подгружать нужные классы. Пространство имен_Doctrine_ содержит очень быстрый и легковесный загрузчик, который можно использовать не только для _Doctrine_, но и других библиотек, если они соответствуют таким требованиям: местоположение классов в дереве каталогов отображается на их именах и пространствах имен, при этом у этих классов должно быть одно общее корневое пространство имен.

> Вы не обязаны использовать только один этот метод для загрузки классов Doctrine. Нет никакой разницы как именно будет загружен класс. Если желаете использовать другой загрузчик, или подключать класс вручную, пожалуйста. Аналогично, загрузчик _Doctrine_ может применяться не только для нее самой, но и для других классов, именование которых соответствует описанным выше стандартам.

Ниже будут приведены несколько типичных конфигураций автозагрузчика для разных способов установки _Doctrine_.

> Для тестирования кода ниже, создайте какой-нибудь файл, наапример test.php.

===== 3.1.1.1. Установка с помощью PEAR
----
<?php  
// test.php  

require 'Doctrine/ORM/Tools/Setup.php';  

Doctrine\ORM\Tools\Setup::registerAutoloadPEAR();
----
===== 3.1.1.2. Установка из TAR-архива
----
<?php  
// test.php  
 require 'Doctrine/ORM/Tools/Setup.php';  

$lib = "/path/to/doctrine2-orm/lib";  
Doctrine\ORM\Tools\Setup::registerAutoloadDirectory($lib);
----
===== 3.1.1.3. Установка из Git-репозитория

Здесь подразумевается, что у вас есть все зависимые пакеты, их можно получить с помощью _git submodule update –init_
----
<?php  
// test.php  
require 'Doctrine/ORM/Tools/Setup.php';  

$lib = '/path/to/doctrine2-orm-root';  
Doctrine\ORM\Tools\Setup::registerAutoloadGit($lib);
----
===== 3.1.1.4. Дополнительные компоненты Symfony

Три приведенных примера подразумевают и загрузку классов Symphony: _Symfony Console_ и _YAML_, которые также могут понадобиться для _Doctrine 2_.

==== 3.1.2. Получение экземпляра EntityManager

Итак, с загрузкой классов закончили, теперь нужно создать экземпляр менеджера сущностей _EntityManager_. Именно через осуществляется вся основная работа в _ORM Doctrine_.

Для настройки _EntityManager_ необходим экземпляр класса _Doctrine\ORM\Configuration_ и параметры подключения к базе данных. Ниже показан возможный вариант настройки.

----
<?php  
use Doctrine\ORM\EntityManager,  
Doctrine\ORM\Configuration;  

// ...  

if ($applicationMode == "development") {  
    $cache = new \Doctrine\Common\Cache\ArrayCache;  
} else {  
    $cache = new \Doctrine\Common\Cache\ApcCache;  
}  

$config = new Configuration;  
$config->setMetadataCacheImpl($cache);  
$driverImpl = $config->newDefaultAnnotationDriver('/path/to/lib/MyProject/Entities');  
$config->setMetadataDriverImpl($driverImpl);  
$config->setQueryCacheImpl($cache);  
$config->setProxyDir('/path/to/myproject/lib/MyProject/Proxies');  
$config->setProxyNamespace('MyProject\Proxies');  

if ($applicationMode == "development") {  
    $config->setAutoGenerateProxyClasses(true);  
} else {  
    $config->setAutoGenerateProxyClasses(false);  
}  

$connectionOptions = array(  
    'driver' => 'pdo_sqlite',  
    'path' => 'database.sqlite'  
);  

$em = EntityManager::create($connectionOptions, $config);
----
> При работе с _Doctrine_ обязательно используйте метаданные и кэш запросов. _Doctrine_, к слову сказать, прекрасно оптимизирована для работы с кешем. Основные части _Doctrine_, которые оптимизированы в плане кеширования -- это метаданные, описывающие отображения (кеш метаданных) и процесс преобразования _DQL_ в _SQL_ (кеш запросов). Для работы кеширования необходимо минимум памяти, при этом оно позволяет значительно повысить производительность. Помимо этого рекомендуется использовать кеширование с помощью инструментов вроде _APC_. Прежде всего, он закеширует ваш байт-код, что будет полезно при любом раскладе. Кроме того, он поставляет высокопроизводительное хранилище прямо в оперативной памяти, в котором можно держать кеши для метаданных и запросов.

==== 3.1.3. Быстрая настройка

Пример выше -- это полноценная настройка всех необходимых параметров _Doctrine_. Можно упростить этот этап, воспользовавшись одним из предопределенных методов конфигурирования:
----
<?php  
use Doctrine\ORM\Tools\Setup;  
use Doctrine\ORM\EntityManager;  

$paths = array("/path/to/entities-or-mapping-files");  
$isDevMode = false;  

$config = Setup::createAnnotationMetadataConfiguration($paths, $isDevMode);  
$em = EntityManager::create($dbParams, $config);  

// Или если вы используете YAML или XML  
$config = Setup::createXMLMetadataConfiguration($paths, $isDevMode);  
$config = Setup::createYAMLMetadataConfiguration($paths, $isDevMode);
----
Тут делается несколько предположений:

Если _$devMode_ установлена в _TRUE_, в качестве механизма кеширования будет использован стандартный _ArrayCache_, а параметр  setAutoGenerateProxyClasses будет установлен в _TRUE_ .

В противном случае, механизм кеширования выбирается в порядке перебора очереди: _APC_, _Xcache_, _Memcache__(127.0.0.1:11211)_. _setAutoGenerateProxyClasses_ в этом случае устанавливается в _FALSE_.

Если третий аргумент (_$proxyDir_) отсутствует, будет использован системный каталог для временных файлов.

=== 3.2. Параметры конфигурации

Следующие разделы описывают все возможные параметры конфигурации экземпляра класса _Doctrine\ORM\Configuration_.

==== 3.2.1. Каталог для прокси (* Обязательно *)
----
<?php  
$config->setProxyDir($dir);  
$config->getProxyDir();
----
Тут происходит установка и получение пути к директории, в которой будут храниться сгенерированные Доктриной прокси-классы. Более детальная информация о прокси-классах и их использовании в _Doctrine_ приведена в разделе “Прокси-объекты” далее по тексту.

==== 3.2.2. Пространства имен для прокси (* Обязательно *)
----
<?php  
$config->setProxyNamespace($namespace);  
$config->getProxyNamespace();
----
Здесь указывается какое пространство имен будет использовано для сгенерированных прокси-классов. Более подробное описание приведено в разделе, посвященном прокси-объектам.

==== 3.2.3. Драйвер метаданных (* Обязательно *)
----
<?php  
$config->setMetadataDriverImpl($driver);  
$config->getMetadataDriverImpl();
----
Код выше демонстрирует как определить какой вариант реализации драйвера метаданных будет использован для обработки метаданных в ваших классах.

Существует 4 разновидности их реализаций:
----
_Doctrine\ORM\Mapping\Driver\AnnotationDriver  
_Doctrine\ORM\Mapping\Driver\XmlDriver_  
_Doctrine\ORM\Mapping\Driver\YamlDriver_  
_Doctrine\ORM\Mapping\Driver\DriverChain_
----
Во многих примерах к этому руководству используется _AnnotationDriver_. Для получения информации об использовании драйверов XML и YAML обратитесь к соответствующим разделам.

Драйвер, работающий с аннотациями настраивается с помощью фабричного метода класса _Doctrine\ORM\Configuration_:
----
<?php  
$driverImpl = $config->newDefaultAnnotationDriver('/path/to/lib/MyProject/Entities');  
$config->setMetadataDriverImpl($driverImpl);
----
Здесь необходимо указать путь к классам сущностей, иначе массовые операции над всеми сущностями, осуществляемые через консоль, не будут работать корректно. Все драйвера метаданных в качестве этого параметра  позволяют указать как одиночную директорию, так и список, это позволит одному единственному драйверу работать с несколькими директориями, в которых лежат сущности.

===== 3.2.4. Кеш метаданных (* Рекомендуется *)
----
<?php  
$config->setMetadataCacheImpl($cache);  
$config->getMetadataCacheImpl();
----
Здесь устанавливается какой механизм будет использоваться для кеширования метаданных, т.е. всей той информации, что вы укажете в аннотациях, через _XML_ или _YAML_, так что при каждом запросе ее не нужно будет заново парсить и обрабатывать, что весьма накладно. Какую бы реализацию вы не выбрали, она должна наследовать общий для всех интерфейс_Doctrine\Common\Cache\Cache_.

Кеширование метаданных очень полезная штука. Нет ни одной адекватной причины, чтобы непользоваться ею.

Для продакшн-среды рекомендуется использовать следующие механизмы кеширования:

_Doctrine\Common\Cache\ApcCache_  
_Doctrine\Common\Cache\MemcacheCache_  
_Doctrine\Common\Cache\XcacheCache_

В среде для разработки более предпочтителен _Doctrine\Common\Cache\ArrayCache_, которые будет постоянно перекешировать данные при каждом запросе.

===== 3.2.5. Кеш запросов (* Рекомендуется *)
<?php  
$config->setQueryCacheImpl($cache);  
$config->getQueryCacheImpl();
Здесь устанавливается возможная реализация механизма кеширования для _DQL_-запросов, т.е. для результата разбора самого выражения _DQL_, которое затем преобразуется в _SQL_ и информацию о том, как обрабатывать набор _SQL_ запросов. Обратите внимание, это не кеш запросов в обычном понимании этого слова, он не затрагивает результаты запроса, так что кеширование не приведет к искажению в данных как это иногда случается. Этот вид кеша создан чисто для оптимизации и не имеет побочных эффектов, кроме разве что небольшого потребления памяти при работе.

Как и для метаданных, крайне рекомендуется использовать кеш и для запросов.

На продакшне используйте эти три варианта:

_Doctrine\Common\Cache\ApcCache_  
_Doctrine\Common\Cache\MemcacheCache_  
_Doctrine\Common\Cache\XcacheCache_

При разработке проще использовать _Doctrine\Common\Cache\ArrayCache_.

===== 3.2.6. Журналирование SQL-запросов (* Опционально *)
----
<?php  
$config->setSQLLogger($logger);  
$config->getSQLLogger();
----
Устанавливается регистратор для сохранения всех _SQL_ запросов, исполняемых через _Doctrine_. Класс регистратора должен определять интерфейс _Doctrine\DBAL\Logging\SQLLogger_. Самый простой вариант реализации журнала находится в _Doctrine\DBAL\Logging\EchoSQLLogger_, он выводит логи на стандартный поток вывода с помощью _echo_ и _var_dump_.

===== 3.2.7. Автоматическое создание классов прокси (* Опционально *)
----
<?php  
$config->setAutoGenerateProxyClasses($bool);  
$config->getAutoGenerateProxyClasses();
----
Определяет, следует ли генерировать классы прокси автоматически во время выполнения скрипта. Если поставить _FALSE_, то классы нужно будет сгененрировать вручную консольной командой с ключом _generate-proxies_. В продакшн среде крайне рекомендуется отключить авто-генерацию.

=== 3.3. Конфигурация для development- и production- сред

Инициализация _Doctrine 2_ должна осуществляться двумя способами с использованием двух различных моделей исполнения. На продакшне лучше использовать _APC_ или _Memcache_, которые имеют много преимуществ в плане производительности. Но при разработке это не совсем то, что нужно, потому что вам не избежать частых ошибок, например, когда вы обновили какую-то сущность, а кеш содержит устаревшие данные. Так что для разработки больше подойдет _ArrayCache_.

Помимо этого, на продакшне следует отключить авто-генерацию прокси классов, при разработке же, наоборот, оставить эту возможность. Включенная авто-генерации может негативно влиять на производительность, например, когда несколько прокси классов будут повторно генерироваться во время исполнения скрипта. В этом случае запросы к файловой системе могут даже больше сказаться на производительности, чем сами запросы к базе данных. Кроме того, прокси устанавливает блокировку на файл, что при выполнении нескольких параллельных запросов будет порождать “бутылочные горлышки” .

=== 3.4. Параметры подключения

Параметр _$connectionOptions_, передаваемый в качестве первого аргумента в метод _EntityManager::create()_ может быть массивом либо экземпляром класса _Doctrine\DBAL\Connection_. Если был передан массив, он сразу же передается в фабричный метод _DBAL Doctrine\DBAL\DriverManager::getConnection()_. Конфигурация _DBAL_ описана в соответствующем разделе.

=== 3.5. Объекты прокси

Прокси -- это объект, который может подставляться и использоваться вместо “реального”. С помощью прокси объекта можно незаметно добавить новый функционал к основному объекту, так что самому объекту об этом беспокоиться не нужно. В_Doctrine 2_ объекты прокси используются для реализации некоторых функций, основная из которых -- ленивая загрузка.

Прокси объекты с помощью ленивой загрузки помогают сохранить взаимосвязь между набором объектов, находящимся в памяти и остальными объектами, которые еще не были загружены. Это очень важное свойство, без которого на границах графа ваших объектов будут всегда находится как бы неполноценные объекты, с некоторым количеством оборванных связей.

В _Doctrine 2_ используется вариация паттерна прокси, которая работает следующим образом: сначала генерируются классы, расширяющие ваши сущности, затем к ним добавляется возможность ленивой загрузки. После этого _Doctrine_ при запросе основного объекта, может вернуть вместо него прокси-версию. Это происходит в двух случаях:

==== 3.5.1. Прокси для ссылок

С помощью метода _EntityManager#getReference($entityName, $identifier)_ можно получить ссылку на сущность по заданному идентификатору без ее загрузки из базы данных. Это бывает полезно, например, в целях повышения производительности, когда нужно установить связь с сущностью, зная ее идентификатор. Вы можете просто сделать следующее:
----
<?php  
// $em это EntityManager, $cart это экземпляр класса MyProject\Model\Cart  
// $itemId идентификатор товара, полученный откуда угодно  
$item = $em->getReference('MyProject\Model\Item', $itemId);  
$cart->addItem($item);
----
Смотрите, мы добавляем товар в корзину без его реальной загрузки из базы данных. Если мы вызовем какой-нибудь метод у нашего объекта _$item_, он будет полностью проинициализирован, его состояние обновится до актуального из базы данных, и это произойдет прозрачно, именно это и называется ленивой загрузкой _(lazy-loading)_. Здесь _$item_ это не что иное как экземпляр прокси класса, который был сгенерирован для класса _Item_, но для вас это не должно иметь значения. Просто забейте, работа объектов прокси полностью прозрачна.

== 3.5.2. Прокси для связей

Второй случай, когда _Doctrine_ использует прокси это при запросах на получение объектов. Всякий раз, когда вы запрашиваете объект, имеющий однозначную взаимосвязь с другим объектом, поддерживающим ленивую загрузку, и при этом не используете _JOIN_, _Doctrine_ заменит все такие объекты их прокси аналогами. Как и остальные прокси объекты, они будут инициализированы при первой же попытке доступа к ним.

> Использование соединений _JOIN_ в _DQL_ или _SQL_, подразумевает “жадную загрузку” всех взаимосвязей. Тем самым для такого запроса будет переопределен параметр _“fetch”_, установленный в отображении для связи.

===== 3.5.3. Генерация классов прокси

Классы прокси можно сгенерировать либо вручную через консольную утилиту _Doctrine_, либо автоматически. Параметр конфигурации, отвечающий за это:
----
<?php  
$config->setAutoGenerateProxyClasses($bool);  
$config->getAutoGenerateProxyClasses();
----
Для большего удобства за параметр по умолчанию принято значение _TRUE_. Однако, на продакшене в целях повышения производительности лучше отключить эту возможность. Не делайте этого в процессе разработки, т.к. это может породить ошибки, связанные с невозможностью загрузки классов (они не будут найдены), либо загрузки устаревших классов. Например, вы добавили новый метод к сущности, а в прокси классе он пока отсутствует. Чтобы избежать этого, заранее сгенерируйте новые прокси через консоль:
----
$ ./doctrine orm:generate-proxies
----

=== 3.6. Несколько источников метаданных

При работе с различными компонентами с помощью _Doctrine 2_, вы можете применять два разных драйвера метаданных, например _XML_ и _YAML_. У вас есть возможность объединить эти драйвера с помощью компонента _DriverChain_ на основе пространств имен:
----
<?php  
$chain = new DriverChain();  
$chain->addDriver($xmlDriver, 'Doctrine\Tests\Models\Company');  
$chain->addDriver($yamlDriver, 'Doctrine\Tests\ORM\Mapping');
----
При этом загрузка определенного пространства имен возлагается на соответствующий драйвер. Драйвер пробегает по всем пространствам имен и ищет совпадения, сравнивая название класса сущности с этим пространством имен при помощью простого выражения _strpos() === 0_. Поэтому, если дочерние пространства имен используют иные реализации драйвера метаданных для обработки, сами драйвера нужно расположить в определенном порядке.

=== 3.7. Репозиторий по-умолчанию (* Опционально *)

Устанавливает полное имя _(Fully-Qualified Class Name, FQCN)_ для дочернего класса _EntityRepository_. Этот класс будет использован для всех сущностей, у которых отсутствует собственный класс репозитория.
----
<?php  
$config->setDefaultRepositoryClassName($fqcn);  
$config->getDefaultRepositoryClassName();
----
По-умолчанию используется класс _Doctrine\ORM\EntityRepository_. Каждый класс репозитория необходимо наследовать от_EntityRepository_, иначе вы получите исключение типа _ORMException_.