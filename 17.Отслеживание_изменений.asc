[[change-tracking-policie]]
== Отслеживание изменений

Отслеживание изменений это процесс определения что именно было изменено в MANAGED-сущностях с последнего момента как они были синхронизированы с базой данных.

В Doctrine доступны 3 политики отслеживания изменений, каждая со своими достоинствами и недостатками. Политику слежения можно задать как для класса так и для иерархии классов.

=== Deferred Implicit

“deferred implicit” -- политика, заданная по умолчанию и как водится наиболее подходящая в большинстве случаев. Doctrine обнаруживает изменения, сравнивая каждое поле во время коммита, кроме того она умеет находить изменения в сущностях, на которые ссылаются другие MANAGED-сущности (“persistence by reachability”). Несмотря на удобство, у этой политики есть и минусы, связанные с производительностью при работе с большими Unit of Work. (см. параграф http://odiszapc.ru/doctrine/architecture/#222_Unit_of_Work[Unit of Work]). Это связано с тем, что когда Doctrine не знает что изменилось, он вынуждена перебирать все MANAGED-сущности при каждом вызове *EntityManager#flush()*, что делает эту операции весьма дорогой.

=== Deferred Explicit

Политика “deferred explicit” чем-то напоминает ”deferred implicit”, у нее такой же принцип отслеживания изменений: во время коммита проверяется каждое поле. Разница в том, что при вызове *EntityManager#persist(entity)* или каскадном сохранении Doctrine будет просматривать только сущности, которые были явно помечены для этого. Все остальные сущности будут опущены. Если вы готовы пожертвовать автоматизацией в пользу производительности, это политика вам подойдет.

Из всего этого следует, что в рамках этой политики вызов flush() гораздо более дешев. Минус здесь следующий. Если у вас большое приложение и бизнес логика такова, что сущности в процессе их обработки бизнес правилами должны пройти несколько слоев, то до того момента как они будут преданы *EntityManager#persist()* вам придется отслеживать изменения самостоятельно.

Политика настраивается следующим образом:
[source, php]
----
<?php
  
/*  
 * @Entity  
 * @ChangeTrackingPolicy("DEFERRED_EXPLICIT")  
 */  
class User  
{  
    // ...  
}
----

=== Notify

Эта политика основана на том, что сущности сами сообщают своим слушателям о происходящих изменениях. Класс, использующий эту политику, должен реализовывать интерфейс *NotifyPropertyChanged *из пространства имен Doctrine (*Doctrine\Common\NotifyPropertyChanged*). Типичная реализация выглядит следующим образом:
[source, php]
----
<?php
  

use Doctrine\Common\NotifyPropertyChanged,  
    Doctrine\Common\PropertyChangedListener;  

/*  
 * @Entity  
 * @ChangeTrackingPolicy("NOTIFY")  
 */  
class MyEntity implements NotifyPropertyChanged  
{  
    // ...  

    private $_listeners = array();  

    public function addPropertyChangedListener(PropertyChangedListener $listener)  
    {  
        $this->_listeners[] = $listener;  
    }  
}
----
Теперь в каждом сеттере для текущего или наследуемого класса нужно уведомлять все экземпляры *PropertyChangedListener*. Чтобы показать как это работает, добавим метод в сущность *MyEntity*:
[source, php]
----
<?php
  

// ...  

class MyEntity implements NotifyPropertyChanged  
{  
    // ...  

    protected function _onPropertyChanged($propName, $oldValue, $newValue)  
    {  
        if ($this->_listeners) {  
            foreach ($this->_listeners as $listener) {  
                $listener->propertyChanged($this, $propName, $oldValue, $newValue);  
            }  
        }  
    }  

    public function setData($data)  
    {  
        if ($data != $this->data) {  
            $this->_onPropertyChanged('data', $this->data, $data);  
            $this->data = $data;  
        }  
    }  
}
----
В каждом методе, который изменяет состояние объекта *MyEntity *следует вызывать *_onPropertyChanged*.

Проверка на предмет того, отличается ли новое значение от предшествующего, не обязательно, но рекомендуется. Так или иначе, у вас полный контроль над процессом, хотите проверяйте, хотите -- нет.

Минус применения этой политики очевиден: нужно реализовывать интерфейс и писать кучу связующего кода. Но заметьте, мы стараемся оставить логику нотификации максимально абстрактной. Строго говоря, нотификация не затрагивает уровень persistence и компоненты Doctrine ORM или DBAL. Так что эта политика может оказаться весьма полезной в соответствующих сценариях. Как уже было отмечено, пространство имен Doctrine/Common состоит исключительно из маленьких классов и интерфейсов, у которых практически отсутствуют внешние зависимости (нет зависимостей от DBAL и ORM компонентов). Можно легко переключиться на другой persistence layer, ничего не поломав.

Положительный момент и главное преимущество этой политики в ее эффективности. Среди всех рассмотренных политик она самая быстрая. Отлично подходит для Unit of Work большого размера, а вызов *flush()* при отсутствии изменения очень дешев.