[[working-with-objects]]

== Работа с объектами

Эта глава поможет понять принципы, на которых строится работа компонентов _EntityManager_ и _UnitOfWork_. _Unit of Work_(Единица работы) это что-то вроде транзакций на уровне объектов. При первом создании _EntityManager_ или после вызова метода _EntityManager#flush()_ неявно произойдет создание новой единицы работы. Коммит этой единицы (и создание новой) происходит при вызове _EntityManager#flush()_.

Вызвав метод _EntityManager#close()_, можно отменить все несохраненные изменения в _Unit of Work_.

> Здесь важно понимать следующее. Только сам _EntityManager#flush()_ непосредственно выполняет запись в базу данных. Все остальные методы, такие как _EntityManager#persist($entity)_ или _EntityManager#remove($entity)_ лишь уведомляют _UnitOfWork_ о последующем исполнении этих операций при вызове метода _flush()_. По сути они лишь подготавливают транзакцию, а flush() исполняет ее.  
> Если не вызвать EntityManager#flush(), то все внесенные в контексте текущего запроса изменения будут утеряны.

=== Паттерн “Карта соответствия” (Identity Map)

Сущности, как нам уже известно, это объекты с некоторыми идентификаторами. Эти идентификаторы имеют концептуальное значение в приложении. Вы, наверное, знаете, что в CMS каждая статья или новость имеет свой уникальный идентификатор, именно за счет него можно отличить одну статью от другой, т.е. идентифицировать ее.

Возьмем следующий пример. В нем мы происходит поиск статьи с заголовком **“Hello World”** и идентификатором **1234**:
[source, php]
----
<?php
  
$article = $entityManager->find('CMS\Article', 1234);  
$article->setHeadline('Hello World dude!');  

$article2 = $entityManager->find('CMS\Article', 1234);  
echo $article2->getHeadline();
----
В этом примере сущность _Article_ дважды запрашивается менеджером сущностей, а между вызовами происходит ее модификация. _Doctrine_ без разницы сколько раз будет запрошен объект из менеджера сущностей. В данном примере _Article_ с_ID_ **1234** всегда будет существовать только в одном экземпляре. И не важно как вы получаете эту сущность: через метод _find_, через репозиторий или через _DQL_. Паттерн, который делает такое поведение возможным, называется картой соответствия_(identity map)_. _Doctrine_ хранит в ней соответствие каждой сущности ее идентификатору, которые были полученные в результате запроса в PHP, и, таким образом, всегда возвращает вам одни и те же экземпляры.

В предыдущем примере в результате вывода на экран вы увидите сообщение **“Hello World dude!”**. Несложно проверить, что**$article** и **$article2** действительно указывают на один и тот же экземпляр:
[source, php]
----
<?php
  
if ($article === $article2) {  
    echo "Yes we are the same!";  
}
----
Иногда нужно полностью очистить карту соответствия менеджера сущностей для того, чтобы начать некоторую процедуру, так сказать, с чистого листа. Этот прием часто используется в юнит-тестах для того, чтобы заставить движок загружать объекты из базы данных, вместо поиска соответствий в карте. Очистить карту соответствий  можно с помощью метода_EntityManager#clear()_.

=== Обход графа сущностей

Хотя Doctrine и позволяет осуществлять полное разделение вашей доменной модели, при обходе связей никогда не возникнет ситуации, когда какие-то объекты будут отсутствовать. Поэтому пробежаться по связям в ваших сущностях можно сколь угодно глубоко.

Возьмем следующий пример, в нем мы получаем единственную статью Article из менеджера сущностей.
[source, php]
----
<?php
  
/** @Entity */  
class Article  
{  
    /** @Id @Column(type="integer") @GeneratedValue */  
    private $id;  

    /** @Column(type="string") */  
    private $headline;  

    /** @ManyToOne(targetEntity="User") */  
    private $author;  

    /** @OneToMany(targetEntity="Comment", mappedBy="article") */  
    private $comments;  

    public function _construct {  
        $this->comments = new ArrayCollection();  
    }  

    public function getAuthor() { return $this->author; }  
    public function getComments() { return $this->comments; }  
}  

$article = $em->find('Article', 1);
----
Здесь происходит получение экземпляра сущности _Article_ с идентификатором **1** путем исполнения единственного запроса_SELECT_. После этого можно получить доступ к ее свойствам **author** и **comments**, а также объектам, которые они содержат.

Это достигается за счет использования паттерна “ленивая загрузка” (lazy loading). Вместо того, чтобы давать доступ сразу к экземпляру _Author_ и коллекции comments _Doctrine_ создаст специальные прокси-объекты, куда и перенаправит вас. И при первом доступе они обратятся к _EntityManager_ и загрузят свое текущее состояние из базы данных. Сделано это для повышения производительности.

Процесс ленивой загрузки работает неявно, он скрыт от ваших глаз (но ничто не мешает отследить его при помощь отладки). Рассмотрим следующий код:
[source, php]
----
<?php
  
$article = $em->find('Article', 1);  

// запрос метода экземпляра сущности запускает ленивую загрузку  
echo "Author: " . $article->getAuthor()->getName() . "\n";  

// Проверим экзмеплар  
if ($article->getAuthor() instanceof User) {  
    // Прокси для класса User реализован в классе UserProxy  
}  

// Запрос комментарие через итерацию также запускает ленивую загрузку,  
// возвращая ВСЕ комментарии этой статьи из базы данных  
// при этом используется один SELECT запрос   
foreach ($article->getComments() AS $comment) {  
    echo $comment->getText() . "\n\n";  
}  

// Article::$comments имеет интерфейся Collection  
 // Но при этом не соответствует интерфейсу ArrayCollection  
if ($article->getComments() instanceof \Doctrine\Common\Collections\Collection) {  
    echo "This will always be true!";  
}
----
Сгенерированные прокси классы выглядят как показано ниже. Реально (чисто конкретно – прим. пер.) такой класс переопределяет все общедоступные методы подобно переопределению метода _getName()_, как показано ниже:
[source, php]
----
<?php
  
class UserProxy extends User implements Proxy  
{  
    private function _load()  
    {  
        // lazy loading code  
    }  

    public function getName()  
    {  
        $this->_load();  
        return parent::getName();  
    }  
    // .. other public methods of User  
}
----
> При обходе графа те его части, которые используют ленивую загрузку, будут порождать много SQL-запросов, и не очень хорошо если это будет происходить слишком часто. Вместо этого используйте DQL, он позволяет делать все за один запрос, агрегируя все сущности в графе в один запрос, это гораздо эффективней.

=== Сохранение сущностей

Сохранить сущность можно с помощью метода _EntityManager#persist($entity)_. После осуществления над сущностью операции сохранения, она получает статус **MANAGED**, который означает, что отныне она персистирована (готова к сохранению в БД) и управляется менеджером сущностей _EntityManager_. После этого персистированная сущность может быть синхронизирована с базой данных вызовом метода _EntityManager#flush()_.

> Передача сущности методу persist не запусукает на исполнение SQL запросы INSERT. Doctrine придерживается транзакционной модели выполнения, которая означает, что SQL-запросы будут придержаны до вызова метода EntityManager#flush(). И только после его вызова они будут выполнены, т.о ваши объекты будут синхронизированы с базой данных через единую транзакцию, что сохранит целостность операции.

Пример:
[source, php]
----
<?php
  
$user = new User;  
$user->setName('Mr.Right');  
$em->persist($user);  
$em->flush();
----
> После вызова метода _flush_ всем идентификаторам и первичным ключам гарантированно будут присвоены значения. Нельзя полагаться на то, что значения они получат сразу после вызова метода persist. Справедливо и обратное -- нельзя полагаться на то, что идентификаторам **не будут** присвоены значения после неудачного вызова метода flush.

Семантика операции персистенции (persist operation), применительно к сущности X, заключается в следующем:

*   Если _X_ является свежесозданной (**NEW**) сущностью, она станет управляемой (**MANAGED**). Сущность X попадет в базу данных после операции _flush()_;
*   Если _X_ является **MANAGED** сущностью, она будет проигнорирована методом _persist()_. Однако, _persist()_ каскадно пройдет по всем сущностям, на которые ссылается _X_, если отношения между _X_ и этими сущностями имеют флаги**cascade=PERSIST** или **cascade=ALL**.
*   Если _X_ является удаленной (**REMOVED**) сущностью, она снова станет управляемой (**MANAGED**).
*   Есил _X_ является отсоединенной (**DETACHED**) сущностью, то метод _flush()_ выбросит исключение.

=== Удаление сущностей

Удалить сущность из постоянного хранилища можно c помощью передачи ее методу _EntityManager#remove($entity)_. При этом сущность будет помечена как **REMOVED**, что означает, что она будет удалена их хранилища при следующем вызове метода _EntityManager#flush()_.

> Тут ситуация аналогичная методу persist() -- вызов метода remove() фактически ничего не удаляет (запросы DELETE не исполняются). Удалена сущность будет лишь после вызова EntityManager#flush(). Это значит, что к запланированным на удаление сущностям по прежнему можно обращаться посредством запросов, и они совершенно спокойно могут появляться в результатах запросов. Для более подробной информации читайте разделhttp://odiszapc.ru/doctrine/working-with-objects/#871_Effects_of_Database_and_UnitOfWork_being_Out-Of-Sync[Database and UnitOfWork Out-Of-Sync].

Пример:
[source, php]
----
<?php
  
$em->remove($user);  
$em->flush();
Семантика операции удаления, применительно к сущности _X_, заключается в следующем:
----
*   Если _X_ является свежесозданной (**NEW**) сущностью, она будет проигнорирована операцией удаления. Однако, _remove()_каскадно пройдет по всем сущностям, на которые ссылается _X_, если отношения между _X_ и этими сущностями имеют флаги **cascade=REMOVE** или **cascade=ALL**
*   Если _X_ является существующей **MANAGED** сущностью, она будет помечена как **REMOVED**.
*   Если _X_ является удаленной (**REMOVED**) сущностью, она будет проигнорирована операцией удаления.
*   Есил _X_ является отсоединенной (**DETACHED**) сущностью, будет выброшено исключение _InvalidArgumentException_.
*   Сущность, помеченная как **REMOVED** будет удалена из базы данных при следующем вызове метода _flush()_.

После того как сущность будет удалена, ее текущее состояние (ее поля) останется таким же как до удаления, за исключением сгенерированных идентификаторов.

Помимо этого, при удалении сущности будут также удалены все связанные с ней записи во всех _“many-to-many”_ таблицах, которые указывают на нее. Произойдет это или нет, зависит от значения атрибута _onDelete _в аннотации _@joinColumn_. Тут два варианта: либо _Doctrine_ вызовет отдельные _DELETE_ запросы для каждой записи в связанных таблицах, либо удаление произойдет на основе внешних ключей при **onDelete=”CASCADE”**.

Удалить сам объект вместе со всеми связанными с ним другими объектами можно несколькими способами, которые значительно отличаются по производительности.

Если связь помечена флагом **CASCADE=REMOVE** _Doctrine 2_ целиком возьмет ее обработку на себя. Если эта связь представляет собой одиночную сущность, она просто будет передана методу _EntityManager#remove()_. Если связь представляет собой коллекцию, _Doctrine_ сделает итерацию по ней и для каждого элемента вызовет _EntityManager#remove()_. В обоих случаях каскадное удаление работает рекурсивно. Для графа, в котором много объектов, выполнять такую операцию будет весьма накладно.

С помощью оператора _DQL DELETE_  можно удалить сразу несколько сущностей без необходимости их обработки. Это больше подходит для удаления больших графов объектов.

Использование семантики внешних ключей **onDelete=”CASCADE”** заставляет базу данных саму произвести удаление всех связанных объектов. Хоть эта стратегия и более сложна, и тут можно конкретно напортачить, но работает это очень быстро, да и сам подход удобен. Однако, следует знать, что использовании первой стратегии (**CASCADE=REMOVE**) заставляет Doctrine полностью исключить из анализа все опции внешних ключей **onDelete=CASCADE**, потому что в данной ситуации _Doctrine_ будет явно запрашивать и удалять все связанные сущности.

=== Отсоединение сущностей

Отсоединить сущность от _EntityManager_ можно как с помощью передачи ее методу _EntityManager#detach($entity)_ так и при каскадной операции отсоединения. После того как сущность была отсоединена все изменения, внесенные в нее (включая операцию удаления) не будут синхронизированы с базой данных.

_Doctrine_, в свою очередь, не будет пытаться хранить ссылки на отсоединенную сущность. 

Пример:
[source, php]
----
<?php
  
$em->detach($entity);
----
Семантика операции отсоединения применительно к сущности _X_, заключается в следующем:

*   Если _X_ является существующей **MANAGED** сущностью, при отсоединении она будет помечена как **DETACHED**. При этом_detach()_ каскадно пройдет по всем сущностям, на которые ссылается _X_, если отношения между _X_ и этими сущностями имеют флаги **cascade=DETACH** или **cascade=ALL**. Сущности, которые до этого ссылались на _X_ продолжат на нее ссылаться.
*   Если _X_ является только что созданной (**NEW**) или уже отсоединенной сущностью, она будет проигнорирована операцией отсоединения.
*   Если _X_ является удаленной (**REMOVED**) сущностью, операция отсоединения каскадно пройдет по всем сущностям, на которые ссылкается _X_, если отношения между _X_ и этими сущностями имеют флаги** cascade=DETACH** или **cascade=ALL**. Сущности, которые до этого ссылались на _X_ продолжают на нее ссылаться.

Существует несколько ситуаций, при которых сущность будет отсоединена автоматически без вызова соответствующего метода: 

*   При вызове метода _EntityManager#clear()_ все сущности, находящиеся под управлением менеджера сущностей будут отсоединены от него.
*   При сериализации сущности. Сущность, полученная при последующей де-сериализации станет отсоединенной. (Это касается всех сущностей, которые были сериализованы и размещены в каком-нибудь кеше, например, при кешировании результатов запросов).

Вообще говоря, отсоединять сущности нужно будет не так часто как, например, удалять и сохранять их.

=== Слияние сущностей

Под объединением имеется ввиду слияние (обычно отсоединенных) сущностей в контекст менеджера _EntityManager_, в результате чего эти сущности снова попадут в общий граф и станут управляемыми (**MANAGED**). Чтобы объединить сущность с графом нужно воспользоваться методом _EntityManager#merge($entity)_. Состояние переданной ему сущности будет объединено в управляемую копию данной сущности, и эта копия будет впоследствии возвращена в качестве результата вызова метода.

Пример:
[source, php]
----
<?php
  
$detachedEntity = unserialize($serializedEntity); // какая-то отсоединенная сущность  
$entity = $em->merge($detachedEntity);  
// $entity теперь ссылается на управляемую копию, возвращенную методом merge().  
// EntityManager $em теперь как обычно может работать с сущностью $entity.
----
> Когда необходимо произвести сериализацию или десериализацию сущности, нужно сделать все ее свойства защищенными (protected), но не закрытыми (private). Причина в том, что когда сериализуется класс, который до этого был экземпляром прокси-объекта, его закрытые члены не будут участвовать в сериализации, о чем PHP выдаст сообщение типа Notice.

Семантика слияния применительно к сущности _X_ заключается в следующем (без бутылки не разобраться):

*   Если _X_ является отсоединенной сущностью, ее состояние будет скопировано на уже существующий экзмепляр сущности_X’_ с тем же идентификатором.
*   Если _X_ новая сущность, будет создана ее управляемая (**MANAGED**) копия _X’_, и состояние _X_ будет скопировано в этот управляемый экземпляр.
*   Если _X_ экземпляр удаленной сущности, будет выброшено исключение _InvalidArgumentException_.
*   Если _X_ является **MANAGED** сущностью, операция слияния проигнорирует ее. Однако, операция _merge()_ каскадно пройдет по всем сущностям, на которые ссылкается _X_, если отношения между _X_ и этими сущностями имеют флаги**cascade=MERGE** или **cascade=ALL**.
*   Для всех сущностей _Y_, на которые ссылается _X_, имеющая флаг **cascade=MERGE** или **ALL**, _Y_ будет рекурсивно смерджена в _Y’_. Для всех таких _Y_, на которые ссылаются _X_,  _X’_ будет ссылаться на _Y’_. (Обратите внимание, если _X_ это управляемая (**MANAGED**) сущность, то экземпляр _X_ это одно и тоже что и _X’_).
*   Если _X_ сущность, которая после слияния перешла в _X’_, и в ней была ссылка на другую сущность _Y_, и при этом не был задан флаг **cascade=MERGE** или **cascade=ALL**, то при попытке перехода по такой связи от _X’_ управление будет передано по ссылке на управляемый объект _Y’_, имеющий такой же постоянный идентификатор, что и _Y_.

Операция слияния может выбросить исключение _OptimisticLockException_ в случае, если сущность была смерджена с использованием оптимистичной блокировки _(optimistic locking)_ чеерез поле с версией и при этом версии смердженной сущности и ее управляемой копии не совпадают. Обычно это означает, что после операции отсоединения сущность была каким-то образом изменена.

В отличии от операции сохранения и удаления, слияние применяется не так часто. Типичный сценарий, где она может пригодится -- когда нужно заново прикрепить сущности к _EntityManager_ после того как они были получены из какого-нибудь кеша (и как следствие до этого были отсоединены).

> Если необходимо сделать множественное слияние сущностей, которые разделют между собой определенные части графа, следует вызвать метод _EntityManager#clear()_ между последовательными вызовами метода_EntityManager#merge()_. В противном случае вы можете получить в базе данных несколько копий одного и того же объекта, но с разными идентификаторами.

> При загрузке отсоединенных сущностей их кеша, если вам не нужно сохранять и удалять их или вы хотите работать с ними без участия сервисов вроде EntityManager, слияние как таковое вам не нужно. Например ничто не мешает передать отсоединенные объекты из кеша напрямую в представление (view).

=== Синхронизация с базой данных

Состояние сохраненных сущностей будет синхронизировано с базой данных при помощи операции _EntityManager#flush()_, которая, в свою очередь, вызовет методы компонента _UnitOfWork_. Синхронизация включает в себя запись в базу данных любых изменений в сущностях и их отношениях. Как описано в главе http://odiszapc.ru/doctrine/association-mapping/[“Отображение связей”], двусторонние отношения сохраняются на основе ссылок, исходящих со стороны владельца.

Когда происходит вызов метода _EntityManager#flush()_, _Doctrine_ анализирует все **MANAGED**-, **NEW**- и **REMOVED**- сущности и выполняет соответствующие этим состояниям операции.

==== Effects of Database and UnitOfWork being Out-Of-Sync

Когда вы изменили состояние сущностей, вызовите метод _persist()_ или _remove()_ компонента _UnitOfWork_ и база данных **will drive out of sync** (???).  Но фактически синхронизированы они могут быть только путем вызова метода _EntityManager#flush()_. Этот раздел описывает **the effects of database and UnitOfWork being out of sync**.

*   Сущности, которые запланированы на удаление, все еще могут быть запрошены из базы данных. Они могут быть получены в результате _DQL_-запросов или через репозитории, также они отображаются в коллекциях.
*   Сущности, переданные методу _EntityManager#persist()_ не будут появляться в результатах запросов.
*   Состояние сущностей, которые были изменены, не будет перезаписано соответствующим их состоянием, уже хранящимся в базе данных. Так происходит потому, что карта соответствия_ (identity map)_ будет каждый раз обнаруживать, что создаваемая сущность уже существует и делать предположение, что это и есть ее наиболее свежая версия.

_EntityManager#flush()_ никогда не вызывается Доктриной автоматически. Вы всегда должны вызывать его вручную.

==== Синхронизация новых (new) и управляемых (managed) сущностей

Операция flush(), применяемая по отношению к управляемым сущностям работает следующим образом:

*   Если у сущности было изменено хотя бы одно поле, она будет синхронизирована в базу данных при помощи _SQL_-запроса_UPDATE_.
*   Если сущность не изменялась, никаких _SQL_-запросов выполнено не будет.

По отношению к новой сущности _flush_ работает так:

*   Сущность будет синхронизирована в базу данных при помощи _SQL_-запроса _INSERT_.
Для всех отношений у **NEW**- и **MANAGED**- сущностей, каждая связанная с ними сущность _X_ будет обработана согласно следующим правилам:
*   Если _X_ была только что создана (**NEW**) и у нее настроена каскадность при сохранении, то _X_ будет сохранена в базе данных.
*   Если _X_ была только что создана (**NEW**) и у нее **не была** задана каскадность при сохранении, будет выброшено исключение.
*   Если _X_ имеет статус **REMOVED** и у нее настроена каскадность при сохранении, будет выброшено исключение (потому что_Doctrine_ попытается повторно сохранить _X_)
*   Если _X_ имеет статус **DETACHED** и у нее настроена каскадность при сохранении, будет выброшено исключение (семантика такая же как и при передаче _X_ методу _persist()_).

==== Синхронизация удаленных сущностей

Если операция _flush_ исполняется по отношению к **REMOVED**- сущности, то такая сущность будет удалена из базы данных. В этом случае при исполнении операции _flush_ опции каскадности не применяются, т.к. каскадное удаление уже отработало при вызове метода _EntityManager#remove($entity)_.

==== Размер Unit of Work

Размер _Unit of Work_ в определенный момент времени представляет собой ни что иное как число _MANAGED_-сущностей на этот момент.

==== Производительность операции flush

Насколько дорога операция _flush_ зависит от двух факторов:

*   Размер текущего “модуля работы” _UnitOfWork_ в менеджере сущностей.
*   Конфигурация политик отслеживания изменений _(change tracking policies)_

Размер _UnitOfWork_ можно узнать следующим образом:
[source, php]
----
<?php
  
$uowSize = $em->getUnitOfWork()->size();
----
Размер в данном случае представляет собой количество обслуживаемых сущностей в модуле Unit of Work. И этот размер непосредственно виляет на производительность _flush()_ за счет отслеживания изменений (см. раздел “Change Tracking Policies”) и потребления памяти, так что при разработке время от времени проверяйте эти параметры.

> Не нужно вызывать flush() при каждом изменении сущности или каждом вызове операций persist, remove, merge и т.д. Это только лишний раз снизит производительность вашего приложения. Вместо этого формируйте модули работы (units of work), которые и будут производить действия над вашими объектами, а когда закончите вызывайте flush(). При обработке одиночного HTTP запроса обычно достаточно не более двух вызовов flush().

==== Прямой доступ к Unit of Work

Получить прямой доступ к _Unit of Work_ можно путем вызова метода _EntityManager#getUnitOfWork()_. Этот метод вернет экземпляр того _UnitOfWork_, который в данный момент используется менеджером сущностей.
[source, php]
----
<?php
  
$uow = $em->getUnitOfWork();
----
> Не оперировать UnitOfWork напрямую. Когда вы напрямую работаете с API UnitOfWork вы используете внтуренние мезанизмы, поэтому внимательно прочтите документацию к API.

==== Состояние сущности

Как уже было отмечено в архитектурном обзоре, сущность может находиться в одном из четырех состояний: **NEW**, **MANAGED**,**REMOVED** и **DETACHED**. Если вам нужно узнать текущее состояние в контексте соответствующего _EntityManager_, можно спросить об этом у лежащего в его основе компонента _UnitOfWork_:
[source, php]
----
<?php
  
switch ($em->getUnitOfWork()->getEntityState($entity)) {  
    case UnitOfWork::STATE_MANAGED:  
    // ...  
    case UnitOfWork::STATE_REMOVED:  
    // ...  
    case UnitOfWork::STATE_DETACHED:  
    // ...  
    case UnitOfWork::STATE_NEW:  
    // ...  
}
----
Сущность находится в состоянии **MANAGED**, если она связана с _EntityManager_ и при этом не имеет статус **REMOVED**.

Сущность находится в состоянии **REMOVED** после того как она была передана методу _EntityManager#remove()_ до последующего вызова _EntityManager#flush()_. **REMOVED**-сущность будет все еще связана с менеджером до следующей операции _flush_.

Сущность находится в состоянии **DETACHED** если она присутствует в хранилище и у нее есть идентификатор, но в данный момент она не связана с _EntityManager_.

Сущность находится в состоянии **NEW** если она отсутствует в хранилище, у нее нет идентификатора и в данный момент она не связана с _EntityManager_ (например она была создана оператором _new). _

=== Запросы

Осуществлять запросы к хранилищу сущностей в Doctrine 2 можно по-разному. Ниже представлены несколько способов, расположенных в порядке возрастания мощи и гибкости. Всегда старайтесь использовать самые простые способы, и только если они не подходят переходите к более навороченным вариантам.

==== По первичному ключу

Самый простой способ запроса объектов заключается в использовании идентификатора в качестве критерия. Делается это при помощи метода _EntityManager#find($entityName, $id)_. Вот пример:
[source, php]
----
<?php
  
// $em instanceof EntityManager  
$user = $em->find('MyProject\Domain\User', $id);
----
Возвращаемое значение представляет собой найденный экземпляр сущности либо _NULL_, если ничего не найдено.

Вообще говоря, _EntityManager#find()_ это просто сокращенная форма следующей записи:
[source, php]
----
<?php
  
// $em instanceof EntityManager  
$user = $em->getRepository('MyProject\Domain\User')->find($id);
----
Метод _EntityManager#getRepository($entityName)_ возвращает объект репозитория, который предоставлят много разных способов получения сущностей соответствующего типа. По умолчанию, экземпляр репозитория имеет тип_Doctrine\ORM\EntityRepository_. Но вы можете создавать свои типы репозиториев, мы позже покажем как это делается.

==== С простыми условиями

Когда нужно запросить одну или несколько сущностей с несколькими условиями, формирующих логическое умножение, используйте методы репозитория _findBy_ и _findOneBy_ как показано ниже:
[source, php]
----
<?php
  
// $em это екзмепляр EntityManager  

// Пользователи, которым 20 лет  
$users = $em->getRepository('MyProject\Domain\User')->findBy(array('age' => 20));  

// 20-летние с фамилией 'Miller'  
$users = $em->getRepository('MyProject\Domain\User')->findBy(array('age' => 20, 'surname' => 'Miller'));  

// Одиночный юзер по нику  
$user = $em->getRepository('MyProject\Domain\User')->findOneBy(array('nickname' => 'romanb'));
----
Можно сделать и так:
[source, php]
----
<?php
  
$number = $em->find('MyProject\Domain\Phonenumber', 1234);  
$user = $em->getRepository('MyProject\Domain\User')->findOneBy(array('phone' => $number->getId()));
----
Обратите внимание, здесь нужно передавать именно **ID** связанной сущность, а нее ее саму.

Метод _EntityRepository#findBy()_ также допускает сортировку и срез результатов путем задания дополнительных параметров:
[source, php]
----
<?php
  
$tenUsers = $em->getRepository('MyProject\Domain\User')->findBy(array('age' => 20), array('name' => 'ASC'), 10, 0);
----
Если в качестве значений фильтра будет передан массив, Doctrine автоматически преобразует его в выражение _WHERE field IN (..):_
[source, php]
----
<?php
  
$users = $em->getRepository('MyProject\Domain\User')->findBy(array('age' => array(20, 30, 40)));  
// Будет преобразовано в: SELECT * FROM users WHERE age IN (20, 30, 40)
----
_EntityRepository_ позволяет использовать более короткую запись вызова методов при момощие магии **_call**. Нижеприведенные примеры вызова полностью эквивалентны:
[source, php]
----
<?php
  
// Ищем одного пользователя по его нику  
$user = $em->getRepository('MyProject\Domain\User')->findOneBy(array('nickname' => 'romanb'));  

// Тоже самое, но при помощи _call  
$user = $em->getRepository('MyProject\Domain\User')->findOneByNickname('romanb');
----
==== “Жадная” загрузка

При запросе сущности, в которй имеются связи, настроенные как **EAGER**, они будут автоматически загружены вместе с запрашиваемой сущностью и будут сразу же доступны приложению.

==== “Ленивая” загрузка

Когда у вас есть **MANAGED**- сущность, можно прозрачно запросить любые ее связи, помеченные как **LAZY**, так, как будто они уже загружены в память. В соответствии с концепцией “ленивой загрузки” все связанные объекты будут автоматически загружены _Doctrine_ при поптыке доступа к ним.

==== С помощью DQL

_Doctrine Query Language_ -- самый мощный и гибкий способ запроса объектов. _DQL_ позволяет написать запрос к объектам на языке самих объектов. _DQL_ понимает классы, поля, наследование и связи. Синтаксически _DQL_ похож на _SQL_, но это не он.

_DQL_-запрос представлен экземпляром класса _Doctrine\ORM\Query_. Создается запрос с помощью метода_EntityManager#createQuery($dql)_. Пример:
[source, php]
----
<?php
  
// $em это экземпляр EntityManager  

// Запрос всех пользователей, имеющих возраст от 20 до 30 лет включительно  
$q = $em->createQuery("select u from MyDomain\Model\User u where u.age >= 20 and u.age <= 30");  
$users = $q->getResult();
----
Заметьте, что этот запрос совершенно не знает о существующей схеме отношений, он оперирует лишь объектной моделью._DQL_ поддерживает как именованные, так и основанные на позиции параметры, множество функций, соединения, агрегации, дочерние запросы и много чего интересного. Более подробная информация о _DQL_ будет рассмотрена в отдельной главе. Для программного построения запросов с условиями в Doctrine есть специальный класс _Doctrine\ORM\QueryBuilder_. Подробно построение запросов с помощью _QueryBuilder_ будет рассмортено в главе _“QueryBuilder”_.

==== Через нативный SQL

В качестве альтернативы DQL можно использовать нативные _SQL_-запросы. Такие запросы пишутся вручную на _SQL_ и настраиваются с помощью _ResultSetMapping_, которая описывает каким именно образом результат _SQL_-запроса будет трактоваться Доктриной. Подробно это будет рассмотрено в отдельной главе.

==== Пользовательские репозитории

Когда вы вызываете метод _EntityManager#getRepository($entityClass)_ _EntityManager_ возвращает вам стандартный репозиторий_Doctrine\ORM\EntityRepository_. Используя метаданные к аннотациям, XML или YAML, можно описать свой класс репозитория. Использование пользовательских репозиториев более предпочтительно в крупных приложениях, использующих тонны различных _SQL_-запросов, потому что запросы будут сгруппирваны в одном месте.
[source, php]
----
<?php
  
namespace MyDomain\Model;  

use Doctrine\ORM\EntityRepository;  

/**  
* @entity(repositoryClass="MyDomain\Model\UserRepository")  
*/  
class User  
{  
}  

class UserRepository extends EntityRepository  
{  
    public function getAllAdminUsers()  
    {  
        return $this->_em->createQuery('SELECT u FROM MyDomain\Model\User u WHERE u.status = "admin"')  
            ->getResult();  
    }  
}
----
Теперь можно обращаться к собственным репозиториям:
[source, php]
----
<?php
  
// $em это экземпляр EntityManager  

$admins = $em->getRepository('MyDomain\Model\User')->getAllAdminUsers();
----