[[architecture]]
:sectnums:

== Архитектура

=== Сущности Doctrine

Сущность -- легковесный хранимый в БД объект из предметной области вашего приложения. Сущностью может являться любой _PHP_ объект, который обладает следующими особенностями:

Сущность не должна быть финальным (_final_) классом или иметь финальные методы.

Все хранимые свойства класса сущности должны быть либо закрытыми (_private_), либо защищенными (_protected_), в противном случае “ленивая загрузка” будет работать некорректно. О ленивой загрузке будет сказано позднее.

В классе сущности не должно быть метода __clone,_ либо определять его нужно с осторожностью.

То же самое касается метода _wakeup_. Постарайтесь вместо него использовать интерфейс _Serializable_.

Если две сущности связаны между собой наследованием (напрямую, либо косвенно), у них не должно быть свойств с одинаковыми именами. Так что, если, например, некая сущность _B_ наследуется от сущности _A_, то у нее не должно быть свойства с теми же именами, которые уже есть в _A_ (которые наследовалось от _A_ к _B_).

В сущности нельзя использовать функцию _func_get_args()_ для того, чтобы узнать параметры вызова. Сгенерированные классы прокси не поддерживают этот подход по причине проблем с производительностью, так что ваш код может работать некорректно.

Сущности поддерживают наследование, полиморфизм для своих связей и запросов. Сущностями могут быть как абстрактные, так и обычные классы. Сущности могут наследоваться как от других сущностей, так и от обычных классов. И, наоборот, обычный класс можно запросто наследовать от сущности.

> Замечание по поводу конструкторов. Конструктор класса сущности будет вызван лишь когда вы сами конструируете экземпляр этого класса с помощью оператора **new**. Сама Doctrine никогда не вызывает конструкторы сущностей, так что можете использовать их для собственных задач и передавать им любые аргументы.

==== Возможные состояния сущностей

Экземпляр определенной сущности может быть иметь из четырех возможных типов: _NEW_, _MANAGED_, _DETACHED_ и _REMOVED_.[red]_(перевод сознательно опущен)_

* _NEW_. Сущность в этом состоянии пока не имеет своего постоянного идентификатора в хранилище, и пока никак не связана с менеджером сущностей (_EntityManager_) и компонентом _UnitOfWork_ (например, она была только что создана оператором _new_).

* _MANAGED_. Существующая сущность со своим идентификатором, находящаяся под управление менеджера сущностей_EntityManager_.

* _DETACHED_. Сущность, идентификатор которой больше не связан с менеджером сущностей или компонентом _UnitOfWork_.

* _REMOVED_. Сущность со своим постоянным идентификатором, связанная с _EntityManager_, которая будет удалена из базы данных при завершении транзакции.

==== Хранимые свойства сущности

Текущее состояние сущности определяется специальными “хранимыми” членами ее экземпляра (они помечаются специальным образом). Доступ к таким переменным должен осуществляться только самими экземпляром объекта сущности с помощью ее методов и никак иначе. Доступ извне к таким полям должен быть закрыт. Обращаться снаружи к ним можно лишь через методы-члены экземпляра класса, например через методы-аксессоры (getter/setter) или другим подобным образом.

Поля-коллекции сущности должны быть определены в соответствии с интерфейсом _Doctrine\Common\Collections\Collection_. Типы коллекций можно использовать для инициализации полей и свойств пока сущность еще не сохранена в базе данных. После того как сущностью станет управляемой (_MANAGED_) или будет отсоединена (_DETACHED_), доступ к ней должен предоставляться через этот интерфейс.

==== Сериализация сущностей

Не рекомендуется использовать сериализацию сущностей, потому как это может породить определенные проблемы, по крайней мере пока она будет содержать ссылки на объекты “прокси” или находиться под управлением _EntityManager_. Если вы все же решите сериализовать или де-сериализовать сущность, которая все еще содержит ссылки на прокси-объекты, то могут появиться проблемы с приватными свойствами из-за технических ограничений. Прокси-объекты определяют метод __sleep_, который не может вернуть имена приватных членов родительских классов. С другой стороны реализовывать интерфейс_Serializable_ тоже не решение, потому что тут нас ждут потенциальные проблемы с циклическими ссылками (пока мы не нашли другого пути, так что если вы знаете больше, сообщите).

=== EntityManager

Класс _EntityManager_ -- центральное звено _ORM_ в _Doctrine 2_. _EntityManager_ позволяет управлять хранимыми объектами и запрашивать их из хранилища.

==== Модель отложенных транзакций

В _EntityManager_ и _UnitOfWork_ применяется стратегия под названием “отложенные транзакции”, которая откладывает исполнение _SQL_-запросов до поры до времени, чтобы затем выполнить их максимально эффективно при завершении транзакции, таким образом, что все блокировки на запись смогут быть быстро освобождены. Представьте себе, что _Doctrine_ это инструмент для синхронизации сущестующих объектов в памяти с базой данных, которая происходит последовательно и небольшиим порциями. Работайте с вашими объектами, изменяйте их, а когда закончите вызовите метод _EntityManager#flush()_и все изменения будут сохранены.

==== Паттерн Unit of Work

Внутри _EntityManager_ используется механизм _UnitOfWork_, который представляет собой реализацию одноименного паттерна http://martinfowler.com/eaaCatalog/unitOfWork.html[Unit of Work]. Он отслеживает все изменения данных в процессе работы и сохраняет их при исполнении транзакции через метод вроде _flush()_. Врядли вам придется работать напрямую с _UnitOfWork_, в основном все задачи будут решаться через класс_EntityManager_.