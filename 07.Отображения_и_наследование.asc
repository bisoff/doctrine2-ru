[[association-mapping]]
== Отображения и наследование

=== Отображение родительских классов

Так называемый отображаемый родительский класс это абстрактный либо обычный класс, который содержит в себе состояние сущности и другую информацию, связанную с отображением, передавая все это путем наследования своим производным классам, при этом он сам сущностью не является. Обычно такой класс может быть полезен когда необходимо задать состояние и информацию, связанную с отображением, которая является общей сразу для нескольких сущностей.

Такие классы, подобно обычным, могут быть вставлены где-то посередине цепочки наследования.

> Кроме того, такой класс сам не может являться сущностью, в нем не будут работать запросы (query), а все отношения, в которых он участвует должны быть односторонними (со стороной владельца). Это означает, что связи типа “один ко многим” в нем невозможны в принципе. Кроме того, связи типа “многие ко многим” возможны лишь в случае, если это родительский класс в данный момент используется только одной сущностью. Для более полной поддержки наследования, следует использовать одно-табличное (single table) или наследование “класс-таблица” (joined table.) О них речь пойдет ниже.

Пример:
[source, php]
----
<?php
  
/** @MappedSuperclass */  
class MappedSuperclassBase  
{  
    /** @Column(type="integer") */  
    private $mapped1;  

    /** @Column(type="string") */  
    private $mapped2;  

    /**  
     * @OneToOne(targetEntity="MappedSuperclassRelated1")  
     * @JoinColumn(name="related1_id", referencedColumnName="id")  
     */  
    private $mappedRelated1;  

   // ... more fields and methods  
}  

/** @Entity */  
class EntitySubClass extends MappedSuperclassBase  
{  
    /** @Id @Column(type="integer") */  
    private $id;  

    /** @Column(type="string") */  
    private $name;  

   // ... тут идут другие поля и методы  
}
_DDL (Data Definition Language)_  для такой схемы будет выглядеть примерно так (для _SQLite_):
CREATE TABLE EntitySubClass (  
    mapped1 INTEGER NOT NULL,  
    mapped2 TEXT NOT NULL,  
    id INTEGER NOT NULL,  
    name TEXT NOT NULL,  
    related1_id INTEGER DEFAULT NULL,  
    PRIMARY KEY(id)  
)
Как видите, здесь присутствует только одна таблица и описывает она дочерний класс. При этом все отображение автоматически было наследовано от класса-родителя так, как будто оно было непосредственно определено в классе-потомке.

=== Наследование с единой таблицей (Single Table Inheritance)

http://martinfowler.com/eaaCatalog/singleTableInheritance.html[Наследование с единой таблицей] это стратегии наследования отображений, в которой все классы в иерархии отображаются на одну единственную таблицу в базе данных. И чтобы определить какая запись каком классу соответствует, используется специальный столбец, называемый _столбцом дискриминатора_.

Пример:
[source, php]
----
<?php
  
namespace MyProject\Model;  

/**  
* @Entity  
* @InheritanceType("SINGLE_TABLE")  
* @DiscriminatorColumn(name="discr", type="string")  
* @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})  
*/  
class Person  
{  
    // ...  
}  

/**  
* @Entity  
*/  
class Employee extends Person  
{  
    // ...  
}
Что здесь стоит отметить:

*   В самом верхнем классе в иерархии  должны быть указаны маркеры _@InheritanceType_, _@DiscriminatorColumn_ и_@DiscriminatorMap_.
*   _@DiscriminatorMap_ определяет какие значения столбца дискриминатора каким классам соответствуют. Например, значение **“person”** говорит о том, что запись имеет тип _Person_, а **“employee”** соответствует типу _Employee_.
*   Названия классов в карте дискриминатора можно полностью не указывать, если они принадлежат одному пространству имен, что и класс, к которому эта карта будет применена.

==== Нюансы при проектировании

Вышеприведенный подход отлично работает когда иерархия типов проста и постоянна. Но когда в иерархию добавляется новый тип и дополнительные поля в существующие родительские типы, это неизбежно порождает добавление новых столбцов в таблицу, что, в свою очередь, может негативно влиять на индексы и расположение столбцов в БД.

==== Производительность

Эта стратегия весьма эффективна как при запросах как ко всем так и к конкретным заданным типам. Дело в том, что здесь не требуется никакого соединения таблиц, идентификаторы типов фигурируют лишь в выражении _WHERE_. В частности, связи с типами, которые используют эту стратегию, работают очень быстро.

Основное правило производительности при одно-табличном наследовании звучит так: если целевая сущность в связях “многие к одному” или “один ко многим” использует стратегию _STI (Single Table Inheritance)_, то в плане производительности более предпочтительно, если она будет “оконечной” сущностью в иерархии наследования (например, у нее не будет потомков). В противном случае _Doctrine_ **не сможет** создать для нее прокси-объекты, и, как следствие, будет **каждый раз** подгружать сущность целиком.

==== Замечания по схеме БД

При работе с устаревшей или самописной схемой БД (без использования SchemaTool) нужно убедиться, что все столбцы, которые не принадлежат корневой сущности (головному классу), но присутствуют в любой из сущностей-потомков, позволяют хранить значения _NULL_. Использование столбцов, имеющих ограничение _“NOT NULL”_ допустимо использовать только в корневой сущности.

=== Наследование с таблицами классов (Class Table Inheritance)

http://martinfowler.com/eaaCatalog/classTableInheritance.html[Наследование с таблицами классов] представляет собой стратегию, в которой каждый класс в иерархии отображается в итоге на несколько таблиц: одну -- его собственную, остальные -- для всех родительских классов. При этом таблица производного класса будет связана с таблицей класс-родителя спомощью внешнего ключа. В _Doctrine 2_ эта стратегия реализована с применением стлбца дискриминатора для “верхней” таблицы в иерархии, потому что это самый простой способ, при котором можно применять полиморфные запросы.

Пример:
[source, php]
----
<?php
  
namespace MyProject\Model;  

/**  
* @Entity  
* @InheritanceType("JOINED")  
* @DiscriminatorColumn(name="discr", type="string")  
* @DiscriminatorMap({"person" = "Person", "employee" = "Employee"})  
*/  
class Person  
{  
    // ...  
}  

/** @Entity */  
class Employee extends Person  
{  
    // ...  
}
Что здесь стоит отметить:

*   _@InheritanceType_, _@DiscriminatorColumn_ и _@DiscriminatorMap_ должны быть указаны в самом верхнем классе в иерархии сущностей.
*   _@DiscriminatorMap_ определяет какие значения столбца дискриминатора каким классам соответствуют. Например, значение **“person”** говорит о том, что запись имеет тип _Person_, а **“employee”** соответствует типу _Employee_.
*   Названия классов в карте дискриминатора можно полностью не указывать, если они принадлежат одному пространству имен, что и класс, к которому эта карта будет применена.
> Когда вы не используете _SchemaTool_ для генерации _SQL_, то имейте ввиду, что при отказе от наследования “класс-таблица” какая бы БД не применялась, будет задействовано свойство внешнего ключа “ON DELETE CASCADE”. Невыполнения этого требования приведет к появлению в ваше базе данных “мертвых записей”.

==== Нюансы при проектировании

Добавление нового типа в иерархию просто порождает включение новой таблицы в общую схему. Подтипы для заданного типа автоматически будут связаны с ним во время выполнения. Кроме того, внесение изменений в любой тип сущности в иерархии путем добавления, редактирования или удаления полей затронет лишь таблицу, непосредственно связанную с данным типом. Так что данная стратегия дает хорошую гибкость, ведь, как уже было сказано, изменение любого типа оказывает влияние лишь на выделенные под него таблицы.

==== Производительность

Эта стратегия из-за своей сути при выполнении практически любого запроса требует нескольких операций _JOIN_, а это негативно сказывается на производительности. Особенно это касается больших таблиц и глубоких иерархий. Когда допустимо использование частичных объектов (partial objects), глобально или для конкретного запроса, то в этом случае запрос к любому типу не будет требовать подключения таблиц для его дочерних типов через _OUTER JOIN_, а это в свою очередь увеличить производительность. Но имейте ввиду, частичные объекты при доступе к полям, определенных в их дочерних типах, не будут подгружать сами себя, поэтому доступ к таким полям будет не безопасен.

Основное замечание, касающееся производительности при наследовании “класс-таблица” звучит так: если целевая сущность в связях “многие к одному” или “один ко многим” использует стратегию _CTI (Class Table Inheritance)_, то в плане производительности более предпочтительно, если она будет “оконечной” сущностью в иерархии наследования (например, у нее не будет классов-потомков). В противном случае _Doctrine_ не сможет создать для нее прокси-объекты, и, как следствие, будет каждый раз подгружать сущность целиком. 

==== Замечания по схеме БД

У каждой сущности в иерархии наследования “класс-таблица” все отображаемые поля должны являться колонками в базе данных применительно к своей сущности. Дополнительно, у каждой дочерней таблицы должен быть столбец _id_, определенный так же как и одноименный столбец в корневой таблице (за исключаением последовательностей (sequences) и автоинкрементных полей). Кроме того, у каждой дочерней таблицы должен быть внешний ключ, являющийся указателем со столбца _id_ этой таблицы на столбец _id_ корневой таблицы, и поддерживающий каскадное удаление.
