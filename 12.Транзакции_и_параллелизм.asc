[[transactions-and-concurrency]]
== Транзакции и параллелизм

=== Разделение транзакций

Разделение транзакций есть ни что иное как определение границ кода работы с БД, которые они будут охватывать. Это немаловажный аспект, ведь от неверного определения границ может снизиться производительность вашего приложения. Многие БД и прослойки вроде библиотеки _PDO_ по умолчанию работают в режиме авто-коммитов, т.о. любой сколь угодно малый SQL-запрос будет завернут в свою отдельную транзакцию. Транзакции -- мощных механизм, поэтому без явного вмешательства со стороны программиста их использование скорее приведет к снижению производительности, чем к ускорению.

К счастью, _Doctrine 2_ уже позаботилась о правильном разделении транзакций: все операции записи (*INSERT* / *UPDATE* /*DELETE*) по умолчанию ставятся в очередь, а когда происходит вызов *EntityManager#flush()*, все они исполняются в рамках единой транзакции.

Помимо этого, в _Doctrine 2_ есть возможность самостоятельно управлять поведением транзакций, и именно такой подход рекомендуется к применению на практике.

Существует два способа работы с транзакциями, рассмотрим их подробнее.

==== Подход 1: косвенный

Первый подход основан на неявной поддержке транзакций механизмом _ORM EntityManager_. Возьмем следующий пример, без явного разграничения на транзакции:
[source, php]
----
<?php
  
// $em это экземпляр EntityManager  
$user = new User;  
$user->setName('George');  
$em->persist($user);  
$em->flush();
----
Здесь мы не задавали транзакции явным образом, поэтому *EntityManager#flush()* сам сделает* commit* или *rollback*. Подобное поведение достигается за счет агрегации _DML_ операций движком _ORM_, этого достаточно если все манипулирование данными работает под эгидой _Unit of Work_ и происходит в контексте модели предметной области и, следовательно, _ORM_.

==== Подход 2: явный

Явный способ работы с транзакциями заключается в использовании напрямую _API Doctrine\DBAL\Connection_. Код будет выглядеть следующим образом:
[source, php]
----
<?php
  
// $em это экземпляр EntityManager  
$em->getConnection()->beginTransaction(); // auto-commit произойдет автоматически  
try {  
    //... какой-то код  
    $user = new User;  
    $user->setName('George');  
    $em->persist($user);  
    $em->flush();  
    $em->getConnection()->commit();  
} catch (Exception $e) {  
    $em->getConnection()->rollback();  
    $em->close();  
    throw $e;  
}
----
Явное управление транзакциями необходимо когда вам нужно включить дополнительные операции DBAL в модуль работы (Unit of Work). Или другой вариант: вам нужно использовать какие-то методы менеджера сущностей, которые требуют активной транзакции. Такие методы будут выдавать исключение типа _TransactionRequiredException_ чтобы информировать вас об этом требовании.

В качестве более удобной альтернативы явному разграничению транзакций можно использовать механизм *control abstractions* в форме методов *Connection#transactional($func)* и *EntityManager#transactional($func)*. Использование таких абстракций, помимо очевидного сокращения объема кода гарантирует, что вы не забудете сделать *rollback* транзакции или закрыть _EntityManager_. Следующий пример является полным эквивалентом предыдущего кода:
[source, php]
----
<?php
  
    // $em это экземпляр EntityManager  
    $em->transactional(function($em) {  
    //... какой-то код  
    $user = new User;  
    $user->setName('George');  
    $em->persist($user);  
});
----
Разница между *Connection#transactional($func)* и *EntityManager#transactional($func)* заключается в том, что последний перед коммитом делает *EntityManager#flush()*, а в случае возникновения исключений корректно закрывает _EntityManager_ (в дополнение к откату транзакции). 

==== Обработка исключений

Если при вызове *EntityManager#flush()* возникнет исключение, транзакция автоматически откатится, а _EntityManager_закроется.

Как было показано на предыдущем примере, при явном разграничении транзакций когда оная терпит неудачу вследствие, например, исключения, происходит откат транзакции, а менеджер сущностей закрывается путем вызова *EntityManager#close()*и работа с ним прекращается. И как было показано ранее, более элегантно это можно сделать при помощи *control abstractions*. Заметьте, после того как вы поймали исключение, нужно будет заново выбросить его. Если вы все же хотите корректно обрабатывать некоторые исключения, нужно явно поймать их в более ранних catch-блоках (но не забудьте в том же месте откатить транзакцию и закрыть _EntityManager_). Все остальные методики обработки исключений стоит применять подобным же образом *(i.e. either log or re-throw, not both, etc.)*

Как результат подобного поведения, все экземпляры сущностей которые имели статус *MANAGED* или *REMOVED* станут*DETACHED*. Отсоединенные объекты получат состояние, которое они имели на момент откат транзакции. *The state of the objects is in no way rolled back and thus the objects are now out of synch with the database*. Приложения может работать с такими отсоединенными объектами, но стоит иметь ввиду, что их состояние может быть неточным.

Если после того как произошло исключение вы захотите начать новый блок (unit of work), это нужно будет делать с новым экземпляром _EntityManager_.

=== Блокировки

Doctrine 2 имеет встроенную поддержку блокировок двух типов: пессимистичной и оптимистичной. Это позволит весьма точно контролировать вопрос того какой вид блокирования больше подходит сущностям именно вашего приложения.

==== Оптимистичная блокировка (Optimistic locking)

Что же, транзакции отлично работают при распараллеливании в одиночном запросе. Однако, транзакция не должна охватывать несколько запросов, это так называемое “время раздумья” (“user think time”). Поэтому длительная “бизнес-транзакция”, которая охватывает несколько запросов должна включать в себя несколько обычных транзакций. По этой причине, одиночные транзакции больше не могут управлять параллелизмом в рамках более длительных бизнес-транзакций. Ответственность за это частично ложиться на само приложение.

_Doctrine_ имеет встроенную поддержку оптимистичной блокировки, реализованной с помощью поля *version*. При таком подходе сущность, которую нужно защитить от одновременного изменения в рамках длительной транзакции получает специальное поле*version*, представляющее собой либо число (тип _integer_) либо временную метку (типа _datetime_). Затем когда в конце длительной операции эта сущность сохраняется происходит сравнение ее текущей версии и версии из базе данных, и, если они не совпадают будет выброшено исключение типа *OptimisticLockException*, которое будет говорить о том, что сущность была изменения кем-то еще.

Назначить версию для сущности можно следующим образом. В примере мы будем использовать целочисленный тип _integer_.
[source, php]
----
<?php
  
class User  
{  
    // ...  
    /* @Version @Column(type="integer") */  
    private $version;  
    // ...  
}
----
В качестве альтернативы можно использовать тип _datetime_ (он отображается на _SQL_ типы _timestamp_ или _datetime_):
[source, php]
----
<?php
  
class User  
{  
    // ...  
    /* @Version @Column(type="datetime") */  
    private $version;  
    // ...  
}
----
Целочесленные версии являются более предпочтительным вариантом по сравнению с временными метками, т.к. они менее подвержены конфликтам в высоконагруженной среде, в противоположность временным меткам, которые зависят от разрешающей способности типа _timestamp_ конкретной СУБД.

Если при вызове* EntityManager#flush()* произойдет конфликт версии, будет выброшено исключение *OptimisticLockException*и произойдет откат активной транзакции (либо она будет поставлена в очередь для отката). Это исключение может быть соответствующим образом поймано и обработано. Возможными реакциями на исключения *OptimisticLockException* могут быть, например, выдача сообщения о конфликте пользователю или попытка обновить и загрузить объекты в новую транзакцию и попытаться повторно ее исполнить.

Время между показом html-формы и фактическим внесением изменений в сущность в самом худшем варианте может достигать времени жизни самой сессии. И если в течение этого периода в сущность были внесены какие-то изменения, то непосредственно при получении сущности будет выброшенго исключение *optimistic locking exception*: (_Оригинал: *If changes happen to the entity in that time frame you want to know directly when retrieving the entity that you will hit an optimistic locking exception*:_)

Вы можете сами проверить версию сущности с помощью *EntityManager#find()*:
[source, php]
----
<?php
  
use Doctrine\DBAL\LockMode;  
use Doctrine\ORM\OptimisticLockException;  

$theEntityId = 1;  
$expectedVersion = 184;  

try {  
    $entity = $em->find('User', $theEntityId, LockMode::OPTIMISTIC, $expectedVersion);  

    // какой-то код  

    $em->flush();  
} catch(OptimisticLockException $e) {  
    echo "Не в огорчение будет сказано, но кто-то уже изменил эту сущность. Примените изменения еще раз!";  
}
----
Или же это можно сделать с помощью метода *EntityManager#lock()*:
[source, php]
----
<?php
  
use Doctrine\DBAL\LockMode;  
use Doctrine\ORM\OptimisticLockException;  

$theEntityId = 1;  
$expectedVersion = 184;  

$entity = $em->find('User', $theEntityId);  

try {  
    // assert version  
    $em->lock($entity, LockMode::OPTIMISTIC, $expectedVersion);  

} catch(OptimisticLockException $e) {  
    echo "Не в огорчение будет сказано, но кто-то уже изменил эту сущность. Примените изменения еще раз!";  
}
----

==== Важные замечания по реализации

Достаточно просто запороть процесс работы с оптимистичной блокировкой если некорректно проводить сравнение версий. Предположим, что есть два пользователя -- Алиса и Боб, пытающиеся получить доступ к банковскому аккаунту:

*   Алиса читает заголовок статьи в блоге, равный *“Foo”*, для версии блокировки с номером* 1* (GET запрос)
*   Боб также читает заголовок статьи в блоге, равный *“Foo”*, для версии блокировки равной *1* (GET запрос).
*   Боб меняет заголовок на *“Bar”*, тем самым обновляя версию на *2* (POST запрос с формы)
*   Алиса меняет заголовок на *“Baz”*, … (POST запрос с формы)

На последнем шаге этого сценария статья блога еще раз будет считана из базы данных до того как будет применено изменения заголовка от Алисы. На этом шаге нужно проверить, что статья все еще имеет версию *1* (этого нет в сценарии)

При правильной работе с оптимистичной блокировкой необходимо добавить поле со значением версии в качестве скрытого поля формы (или, для большей безопасности, в сессию). В противном случае вы не сможете удостовериться в том, что версия та же самая, что и была при чтении из базы когда Алиса выполняла свой GET запрос. Если это случится, вы потеряете часть обновлений; произойдет то, чего вы пытались избежать с помощью оптимистичной блокировки.

Рассмотрим пример. Есть форма (GET запрос):
[source, php]
----
<?php
  
$post = $em->find('BlogPost', 123456);  

echo 'getId() . '" />';  
echo 'getCurrentVersion() . '" />';
----
А вот код изменения заголовка (POST запрос):
[source, php]
----
<?php
  
$postId = (int)$_GET['id'];  
$postVersion = (int)$_GET['version'];  

$post = $em->find('BlogPost', $postId, \Doctrine\DBAL\LockMode::OPTIMISTIC, $postVersion);
----

==== Пессимистичная блокировка (Pessimistic Locking)

В Doctrine 2 пессимистичная блокировка поддерживается на уровне СУБД. Не предпринималось никаких попыток реализовать этот функционал внутри самой _Doctrine_, правильнее использовать возможности конкретной СУБД и команды ANSI-SQL реализации блокировки на уровне строк. Любая сущность может работать в рамках такой блокировки, для этого не нужно определять никаких специальных параметров.

Однако, для того, чтобы пессимистичная блокировка заработала как положено вам нужно отключить режим авто-коммитов в СУБД, а код, ориентированный на использование такой блокировки должен быть обернут в транзакцию, как это описано в разделе http://odiszapc.ru/doctrine/transactions-and-concurrency/#1012_2[10.1.2. Подход 2: явный] данной главы. Если вы попробуете использовать пессимистичную блокировки вне транзакции_Doctrine 2_ выбросит исключение.

В настоящий момент поддерживаются 2 режима блокировки:

*   *Pessimistic Write* (Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE), блокирует строки базы данных от параллельных операций чтения и записи.
*   *Pessimistic Read* (Doctrine\DBAL\LockMode::PESSIMISTIC_READ), блокирует иные параллельные запросы, которые пытаются обновить строки или залочить их в режиме записи.

Использовать пессимистичные блокировки можно тремя различными способами:

1.  Используя *EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)* или *EntityManager#find($className, $id, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)*
2.  Используя *EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)* или *EntityManager#lock($entity, \Doctrine\DBAL\LockMode::PESSIMISTIC_READ)*
3.  Используя *Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_WRITE)* или *Query#setLockMode(\Doctrine\DBAL\LockMode::PESSIMISTIC_READ)*