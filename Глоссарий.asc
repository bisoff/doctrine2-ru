[[glossary]]

[glossary]
[preface]

== Глоссарий

Annotations::

Аннотации. Комментарии, несущие смысловые последствия в интерпретации кода.

Ass::

Некоторые предложения по тексту глав вызывали именно такое определение, по этой причине я не смог их перевести, не обессудьте.

Association::

Ассоциация. Взаимосвязь. Связь. Отношение. У сущности кроме простых полей могут быть поля, олицетворяющие ее взаимосвязь с другими сущностями. Что-то вроде отношений в базах данных (собственно это они и есть, но покрытые слоем абстракции ORM). Я предпочитаю называть это просто связью. Это соединения между сущностями.

Collection::

Коллекция, список. Используется в контексте отношений “один ко многим” и “многие ко многим”. Похожи на массив, но конечно более навороченная концепция.

DQL::

Язык запросов Doctrine. Чем-то похож на SQL. Не вижу смысла переводить аббревиатуру.

DiscriminatorColumn::

Столбец дискриминатора. Столбец дискриминатора содержит значение, которое определяет, какому классу принадлежит каждая запись. Что это такое? Это пошло еще с Java Hibernate.
Например, рассмотрим таблицу Persons, которая содержит данные всех сотрудников компании. Некоторые лица являются служащими, а некоторые — менеджерами. Таблица Persons содержит столбец с именем EmployeeType, который имеет значение 1 для менеджеров и значение 2 для служащих; это и есть столбец дискриминатора. В этом случае можно создать подкласс служащих и заполнить класс только записями, которые имеют в столбце EmployeeType значение 2. Кроме того, можно удалить из каждого класса неприменимые столбцы.

Entity, Persistent classes::

Сущность, хранимый (персистентный) класс. По сути одно и тоже. Основная концепция Doctrine. Сущностью может быть одна таблица, либо таблица со связанными с ней другими таблицами. Да что там, сущностью может быть целая база данных! Чтобы класс считался хранимым (то есть обрабатывался Доктриной) он должен быть помечен как сущность при помощи метаданных, например аннотацией к классу со свойством @Entity:
[source, php]
----
/** @Entity */
class Entity_MyItem
{
}
----

Metadata, Оbject-relational mapping metadata::
Метаданные. Набор параметров, описывающих как объектная модель будет проецироваться на физическую модель в базе данных. Эти директивы превращают обычный класс в сущность. Вы берете обычный класс, добавляете к нему метаданные и все — вот она ваша сущность. Метаданные могут быть определены тремя strong textспособами:

* XML
* YAML
* Аннотации DocBlock (комментарии в PHP-коде)

Hydration::

Гидрация. Вменяемого перевода на русский нет. Процесс гидрации – это процедура преобразования результата SQL запроса в объектную модель. В этот момент создаются экземпляры сущностей, подключаются связи и так далее.

Inverse/owning side::

Владеющая (прямая) и обратная стороны связи. Что это значит? К примеру, у вас есть сущность “Новость” и есть сущность “Комментарий”. У одной новости может быть несколько комментариев, поэтому комментарий содержит в себе ссылку на новость (физически в базе данных есть соответствующее поле, вроде new_id). Как вы видите, это классический пример отношения “один ко многим”, где “один” это новость, а “многие” это комментарии. Комментарии однозначно связаны с новостью, поэтому они — сторона владельца или прямая сторона. Это позволяет из сущности комментария перейти к сущности новости. Обратная сторона связи позволяет из новости получить указатель на ее комментарии.

Mapping::

Отображение. Соответствия. Основная концепция любой ORM. Отображение объектной структуры на модель базы данных.

Metadata drivers::

Драйвер метаданных. Управляют различными способами представления метаданных (XML, YAML, аннотации Dockblock).

Metadata Cache::

Кеш метаданных. Чтобы каждый раз не парсить метаданные.

Orphan removal::

Переводится как “удаление объектов-сирот”. Технология каскадного удаления объектов, на которые потеряны ссылки. Пример с новостями и комментариями: комментарий связан с новостью, при удалении новости сам комментарий перестает иметь смысл (конечно если вы не решите иначе). Так вот данный подход позволяет удалить его автоматически, если связь содержащая такой комментарий была соответствующим образом настроена.

Partial objects::

“Обрезанные объекты” без некоторых внешних связей. Вы сами задаете какие поля объекта будут запрошены из базы. Иными словами, вы получите объект у которого будут отсутствовать некоторые поля. Partial Objects сделаны для повышения производительности в узких местах, но, честно говоря, реальный профит от них под большим вопросом, MySQL очень быстр.

Persistent properties::

Хранимые свойства. Хранимые члены. Свойства класса сущности, непосредственно имеющие отношения к базе данных. Именно они и олицетворяют сущность как таковую. Такие свойства помечены соответствующими тегами в аннотациях к ним.

Proxy classes::

Классы прокси. Прокси. Классы-заглушки. Используются для ускорения.

Query cache::

Кеш запросов. Не то, что вы подумали. Он кеширует не результаты SQL запросов, а результат разбора запроса DQL.

Schema-Tool::

Инструмент для работы со схемой данных. Он перестраивает ее, удаляет, создает. Переводить не нужно.

