[[association-mapping]]
== Отображение связей

В этой главе приводится описание того как Doctrine работает со связанными сущностями, т.е. сущностями, между которыми существуют некоторые отношения. Для начала будет дано описание концепции прямой и обратной сторон связи. Это очень важный момент, он поможет понять принцип работы двусторонних связей. Главное, нужно усвоить, что связи могут быть одно- и дву- сторонними.

=== Прямая и обратная стороны связи

При работе с двусторонними связями важно понимать суть прямой (owning) и обратной (inverse) сторон связи. Давайте начнем с простых правил:

*   Отношения межу сущностями могут быть двусторонними и односторонними.
*   У двустороннего отношения есть как прямая сторона (сторона владельца), так и обратная сторона.
*   У односторонних отношений есть только прямая сторона.
*   Именно прямая сторона отношения непосредственно влияет на все изменения, которые будут внесены в него в процессе работы приложения.

Для **двусторонних** связей справедливы следующие правила:

*   Обратная сторона отношения должна ссылаться на основную сторону с помощью атрибута __mappedBy__, который используется в аннотациях __OneToOne__, __OneToMany__ и __ManyToMany__. Этот атрибут указывает на поле сущности, которое является “владельцем” этого отношения (и это поле расположено на “противоположном” конце связи).
*   И наоборот, прямая сторона двустороннего отношения ссылается на обратную сторону с помощью атрибута __inversedBy__, который также используется в аннотациях __OneToOne__, __ManyToOne__ и __ManyToMany__. Этот атрибут указывает на поле сущности, которое является обратной стороной отношения.
*   В отношениях типа __OneToMany__ и __ManyToOne__ именно “Many”-сторона является прямой стороной связи, поэтому на ней нельзя использовать атрибут __mappedBy__ -- он применяется только на обратной стороне.
*   Для двусторонних отношений типа __OneToOne__ прямой стороной связи является та, которая содержит соответствующий внешний ключ (он описывается аннотацией __@JoinColumn(s))__.
*   В отношениях типа __ManyToMany__ любая сторона может быть прямой. __(Непонятно: the side that defines the @JoinTable and/or does not make use of the mappedBy attribute, thus using a default join table.)__

Несколько запутанно, правда? На самом деле все не так сложно. Самое главное, запомните:

**Именно прямая сторона связи определяет какие изменения в существующем отношении попадут в базу данных.**

Чтобы понять это, давайте вспомним как работают двусторонние отношения в мире объектов. Возьмем два объекта, между которыми существует связь. На каждой стороне этой связи существует по ссылке, каждая из которых представляет эту самую связь, но изменять эти ссылки можно независимо друг от друга. Безусловно, в правильно спроектированном приложении вся семантика двусторонних связей должна полностью контролироваться разработчиком, это его ответственность. При использовании __Doctrine__ ей просто нужно указать, какую из этих ссылок нужно хранить в базе данных, а какая там хранится не должна, потому что обе ссылки хранить невозможно, это абсурд. В этом и заключается концепция прямой и обратной связей.

Когда изменения в отношение вносятся только с обратной стороны связи, __Doctrine__ их проигнорирует. Поэтому для двусторонних отношений нужно всегда обновлять обе стороны (ну или с точки зрения Doctrine, хотя бы прямую сторону). Сторона владельца в двусторонней связи -- эта та точка, в которой находится условный наблюдатель от __Doctrine__ __(ха-ха, прямо как на выборах, прим. перев.)__, анализирующий связь, именно так она определяет текущее состояние связи и сам факт ее изменения (например, есть ли необходимость обновить ее в базе данных).

> Концепция прямой и обратной сторон является одним из краеугольных камней технологии __ORM__ и к предметной области вашего приложения она не имеет отношения. Поэтому то, что в вашем приложении понимается под стороной владельца, в терминах __Doctrine__ может трактоваться иначе. И на самом деле это не играет роли.

=== Коллекции

В примерах к этой главе при рассмотрении связей типа “ко многим” мы будет использовать специальный интерфейс __Collection__и соответствующую ему реализацию __ArrayCollection__, которая определена в пространстве имен __Doctrine\Common\Collections__. Для чего это нужно и почему нельзя использовать простые массивы? К сожалению, массивы в __PHP__, конечно, удобны во многих случаях, но с их помощью нельзя полноценно представлять наборы объектов бизнес-логики, особенно вне контекста __ORM__. Причина состоит в том, что стандартные массивы __PHP__ не могут быть прозрачно расширены для работы с продвинутыми фишками __ORM__. Классы и интерфейсы, которые лежат ближе всего к концепции коллекции, это __ArrayAccess__ и __ArrayObject__, но пока экземпляры этих классов не смогут применятся в тех же конструкциях, где применяются обычные массивы (возможно, это будет сделано в __PHP6__), эффективность их будет ограничена. В принципе, можно использовать и __ArrayAccess__ вместо __Collection__, ведь интерфейс __Collection__ расширяет __ArrayAccess__, но это не даст вам нужной гибкости работы с коллекциями, потому что__API__ __ArrayAccess__ весьма примитивен (и это сделано специально), и, что более важно, нельзя будет передать эту коллекцию в всякие __PHP__ функции, что делает работу с ней очень сложной.

> Интерфейс __Collection__ и класс __ArrayCollection__, как и все в пространстве имен __Doctrine__, не относится ни к компоненту __ORM__, ни к __DBAL__. Это просто обычный __PHP__ класс,  не имеющий никаких внешних зависимостей за исключением разве что __PHP__ и библиотеки __SPL__. Использование этого класса в приложении не требует его непосредственного контактирования со слоем, управляющим хранением данных (persistent layer). Класс __Collection__, как и все в модуле __Common__, не являются частью этого слоя. Вы можете вообще удалить __Doctrine__, оставив один этот класс, и весь код, его использующий продолжит нормально функционировать.

=== Параметры отображения по-умолчанию

Прежде чем мы начнем описывать все возможные отображения для связей, вам следует уяснить следующее. В процессе описания связей будут применяться аннотации __@JoinColumn__ и __@JoinTable__. Они определяют какие столбцы в БД будут непосредственно отвечать за связь. Эти аннотации являются опциональными и имеют значения по умолчанию. Для отношения типов __OneToOne__ или __ManyToOne__, используются следующие дефолтные значения:
name: "_id"  
referencedColumnName: "id"
Давайте для примера рассмотрим такое отображение:

*PHP*
[source, php]
----
/** @OneToOne(targetEntity="Shipping") */  
private $shipping;
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity class="Product">  
        <one-to-one field="shipping" target-entity="Shipping" />  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
Product:  
    type: entity  
    oneToOne:  
        shipping:  
            targetEntity: Shipping
Это абсолютно тоже самое, что и следующий, более навороченный вариант:
----

*PHP*
[source, php]
----
/**  
* @OneToOne(targetEntity="Shipping")  
* @JoinColumn(name="shipping_id", referencedColumnName="id")  
*/  
private $shipping;
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity class="Product">  
        <one-to-one field="shipping" target-entity="Shipping">  
            <join-column name="shipping_id" referenced-column-name="id" />  
        </one-to-one>  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
Product:  
    type: entity  
    oneToOne:  
        shipping:  
            targetEntity: Shipping  
            joinColumn:  
                name: shipping_id  
                referencedColumnName: id
----
Конструкция __@JoinTable__, используемая для отображения связей __ManyToMany__ имеет аналогичные значения по умолчанию:

*PHP*
[source, php]
----
class User  
{  
    //...  
    /** @ManyToMany(targetEntity="Group") */  
    private $groups;  
    //...  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity class="User">  
        <many-to-many field="groups" target-entity="Group" />  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToMany:  
        groups:  
            targetEntity: Group
----
В более полной нотации это выглядит так:

*PHP*
[source, php]
----
class User  
{  
    //...  
    /**  
    * @ManyToMany(targetEntity="Group")  
    * @JoinTable(name="User_Group",  
    * joinColumns={@JoinColumn(name="User_id", referencedColumnName="id")},  
    * inverseJoinColumns={@JoinColumn(name="Group_id", referencedColumnName="id")}  
    * )  
    */  
    private $groups;  
    //...  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity class="User">  
        <many-to-many field="groups" target-entity="Group">  
            <join-table name="User_Group">  
                <join-columns>  
                    <join-column id="User_id" referenced-column-name="id" />  
                </join-columns>  
                  
                    <join-column id="Group_id" referenced-column-name="id" />  
                  
            </join-table>  
        </many-to-many>  
    </entity>  
 </doctrine-mapping>
----
*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToMany:  
        groups:  
            targetEntity: Group  
            joinTable:  
                name: User_Group  
                joinColumns:  
                    User_id:  
                        referencedColumnName: id  
                inverseJoinColumns:  
                    Group_id:  
                        referencedColumnName: id
----
В этом варианте имя таблицы, используемой для связи по умолчанию соответствует неполным именам участвующих в отношении классов, разделенных символом подчеркивания. Имена столбцов в этой таблице по умолчанию складывается из неполного имени целевого класса с суффиксом “**_id**“. Параметр **referencedColumnName** по умолчанию всегда равен “**id**“, это справедливо как для отношений “один к одному”, так и для “многие к одному”.

Если вас устраивают значения по-умолчанию можно не писать лишнего кода.

=== Инициализация коллекций

При работе с полями, содержащими коллекции сущностей стоит быть внимательным. Допустим, у нас есть сущность __User__, которая содержит коллекцию групп:
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    /** @ManyToMany(targetEntity="Group") */  
    private $groups;  

    public function getGroups()  
    {  
        return $this->groups;  
    }  
}
----
Если рассматривать этот код отдельно, то видно, что поле __$groups__ является только экземпляром класса __Doctrine\Common\Collections\Collection__, и пользователь может запросить его с помощью соответствующего метода. Однако,  сразу после создания объекта __User__ поле __$groups__, очевидно, будет иметь значение __NULL__.

Такие поля нужно заранее инициализировать в конструкторе пустыми объектами __ArrayCollection__:
[source, php]
----
<?php
  
use Doctrine\Common\Collections\ArrayCollection;  

/** @Entity */  
class User  
{  
    /** @ManyToMany(targetEntity="Group") */  
    private $groups;  

    public function __construct()  
    {  
        $this->groups = new ArrayCollection();  
    }  

    public function getGroups()  
    {  
        return $this->groups;  
    }  
}
----
Вот. И теперь следующий код будет нормально работать даже если сущность еще не связана с менеджером __EntityManager__:
[source, php]
----
<?php
  
$group = $entityManager->find('Group', $groupId);  
$user = new User();  
$user->getGroups()->add($group);
----

=== Валидация отображений в различных средах (Runtime и Development)

По причинам, связанным с производительностью __Doctrine 2__ не производит полную валидацию связи, т.е. проверку на предмет того правильно ли она мэппится на схему базы данных. Нужно самостоятельно проверять корректно ли настроена та или иная связь. Сделать это через командную строку:
doctrine orm:validate-schema
Либо выполнить валидацию вручную:
[source, php]
----
<?php
  
use Doctrine\ORM\Tools\SchemaValidator;  

$validator = new SchemaValidator($entityManager);  
$errors = $validator->validateMapping();  

if (count($errors) > 0) {  
    // Lots of errors!  
    echo implode("\n\n", $errors);  
}
----
> Если с отображением что-то не так, массив __$errors__ будет содержать сообщения об ошибках. Единственный параметр, валидация которого не производится, это __referencedColumnName__. Он должен всегда равняться первичному ключу, иначе __Doctrine__ вообще не будет работать.

> Основная ошибка заключается в использовании обратного слеша в полном имени класса. Когда вы записываете это имя в виде строки (например в настройках отображения) обратный слеш в начале строки нужно убрать. Для обратной совместимости __PHP__ делает это с помощью функции __get_class()__ или с помощью механизма рефлексии.

=== Отношения “один к одному”, односторонние

Односторонние связи типа “один к одному” являются, наверное, самыми распространенными. Вот вам пример: сущность__Product__ (товар) имеет один объект __Shipping__ (отгрузка товара). При этом в __Shipping__ нет ссылки обратно на __Product__, поэтому отношение и называется односторонним: __Product -> Shipping__.

*PHP*
[source, php]
----
/** @Entity */  
class Product  
{  
    // ...  

   /**  
    * @OneToOne(targetEntity="Shipping")  
    * @JoinColumn(name="shipping_id", referencedColumnName="id")  
    */  
    private $shipping;  

   // ...  
}  

/** @Entity */  
class Shipping  
{  
    // ...  
}
----

*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity class="Product">  
        <one-to-one field="shipping" target-entity="Shipping">  
            <join-column name="shipping_id" referenced-column-name="id" />  
        </one-to-one>  
    </entity>  
</doctrine-mapping>
----

*YAML*
[source, YAML]
----
Product:  
    type: entity  
    oneToOne:  
        shipping:  
            targetEntity: Shipping  
            joinColumn:  
                name: shipping_id  
                referencedColumnName: id
----
Обратите внимание, что использовать аннотацию @JoinColumn здесь не обязательно, т.к. значение по умолчанию дадут то же результат.

Итоговая схема MySQL будет выглядеть так:
[source, sql]
----
CREATE TABLE Product (  
    id INT AUTO_INCREMENT NOT NULL,  
    shipping_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE Shipping (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE Product ADD FOREIGN KEY (shipping_id) REFERENCES Shipping(id);
----

=== Отношения “один к одному”, двусторонние

В качестве примера возьмем отношения между объектами __Customer__ (заказчик) и __Cart__ (корзина). Смотрите, у __Cart__ есть обратная ссылка на __Customer__, поэтому эта связь является двусторонней:

*PHP*
[source, php]
----
/** @Entity */  
class Customer  
{  
    // ...  

   /**  
    * @OneToOne(targetEntity="Cart", mappedBy="customer")  
    */  
    private $cart;  

   // ...  
}  

/** @Entity */  
class Cart  
{  
    // ...  

   /**  
    * @OneToOne(targetEntity="Customer", inversedBy="cart")  
    * @JoinColumn(name="customer_id", referencedColumnName="id")  
    */  
    private $customer;  

   // ...  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="Customer">  
        <one-to-one field="cart" target-entity="Cart" mapped-by="customer" />  
    </entity>  
    <entity name="Cart">  
        <one-to-one field="customer" target-entity="Customer" inversed-by="cart">  
            <join-column name="customer_id" referenced-column-name="id" />  
        </one-to-one>  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
Customer:  
    oneToOne:  
        cart:  
            targetEntity: Cart  
            mappedBy: customer  
Cart:  
    oneToOne:  
        customer:  
            targetEntity: Customer  
            inversedBy: cart  
            joinColumn:  
                name: customer_id  
                referencedColumnName: id
----
Обратите внимание, что использовать аннотацию __@JoinColumn__ здесь не обязательно, т.к. значение по-умолчанию дадут то же результат.

Итоговая схема __MySQL__ будет выглядеть так:
[source, sql]
----
CREATE TABLE Cart (  
    id INT AUTO_INCREMENT NOT NULL,  
    customer_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE Customer (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE Cart ADD FOREIGN KEY (customer_id) REFERENCES Customer(id);
----
Посмотрите как определен внешний ключ на прямой стороне отношения -- таблице __Cart__.

=== Отношения “один к одному” со ссылкой на себя же

Такие отношения в __Doctrine__ реализовываются весьма просто:
[source, php]
----
/** @Entity */  
class Student  
{  
    // ...  

   /**  
    * @OneToOne(targetEntity="Student")  
    * @JoinColumn(name="mentor_id", referencedColumnName="id")  
    */  
    private $mentor;  

   // ...  
}
----
Обратите внимание, что использовать аннотацию __@JoinColumn__ здесь не обязательно, т.к. значение по умолчанию дадут то же результат.

Итоговая схема __MySQL__ будет выглядеть так:
[source, sql]
----
CREATE TABLE Student (  
    id INT AUTO_INCREMENT NOT NULL,  
    mentor_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE Student ADD FOREIGN KEY (mentor_id) REFERENCES Student(id);
----

=== Отношения “один ко многим”, односторонние, с использованием @JoinTable

Односторонние связи типа “один ко многим” можно определять через подсоединяемую таблицу. С точки зрения Doctrine это выглядит как одностороннее отношение “многие ко многим”, где у одной из подсоединяемых колонок указан флаг уникальности, это и обеспечивает функционирование подобно отношениям “один ко многим”. Следующий пример описывает сказанное:

*PHP*
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToMany(targetEntity="Phonenumber")  
     * @JoinTable(name="users_phonenumbers",  
     * joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},  
     * inverseJoinColumns={@JoinColumn(name="phonenumber_id", referencedColumnName="id", unique=true)}  
     * )  
     */  
    private $phonenumbers;  

    public function __construct() {  
        $this->phonenumbers = new \Doctrine\Common\Collections\ArrayCollection();  
    }  

    // ...  
}  

/** @Entity */  
class Phonenumber  
{  
    // ...  
}
----

*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="User">  
        <many-to-many field="phonenumbers" target-entity="Phonenumber">  
            <join-table name="users_phonenumbers">  
                <join-columns>  
                    <join-column name="user_id" referenced-column-name="id" />  
                </join-columns>  
                  
                    <join-column name="phonenumber_id" referenced-column-name="id" unique="true" />  
                  
            </join-table>  
        </many-to-many>  
    </entity>  
</doctrine-mapping>
----

*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToMany:  
        phonenumbers:  
            targetEntity: Phonenumber  
            joinTable:  
                name: users_phonenumbers  
                joinColumns:  
                    user_id:  
                    referencedColumnName: id  
                inverseJoinColumns  
                    phonenumber_id:  
                        referencedColumnName: id  
                        unique: true
----
> Описанные отношения работают только с использованием аннотации __@ManyToMany__ совместно с ограничителем__unique.__

Итоговая схема __MySQL__ будет выглядеть так:
[source, sql]
----
CREATE TABLE USER (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE users_phonenumbers (  
    user_id INT NOT NULL,  
    phonenumber_id INT NOT NULL,  
    UNIQUE INDEX users_phonenumbers_phonenumber_id_uniq (phonenumber_id),  
    PRIMARY KEY(user_id, phonenumber_id)  
) ENGINE = InnoDB;  

CREATE TABLE Phonenumber (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE users_phonenumbers ADD FOREIGN KEY (user_id) REFERENCES USER(id);  
ALTER TABLE users_phonenumbers ADD FOREIGN KEY (phonenumber_id) REFERENCES Phonenumber(id);
----

Отношения “многие к одному”, односторонние

Отношение типа “многие к одному” определяются следующим образом:

*PHP*
[source, php]
----
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToOne(targetEntity="Address")  
     * @JoinColumn(name="address_id", referencedColumnName="id")  
     */  
    private $address;  
}  

/** @Entity */  
class Address  
{  
    // ...  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="User">  
       <many-to-one field="address" target-entity="Address" />  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToOne:  
        address:  
            targetEntity: Address
----
> Обратите внимание, что использовать аннотацию __@JoinColumn__ здесь не обязательно, т.к. по умолчанию и так будут использоваться колонки __address_id__ и __id__. Можно их и не указывать.

Итоговая схема MySQL будет выглядеть так:
[source, sql]
----
CREATE TABLE USER (  
    id INT AUTO_INCREMENT NOT NULL,  
    address_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE Address (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE USER ADD FOREIGN KEY (address_id) REFERENCES Address(id);
----

=== Отношения “один ко многим”, двусторонние

Двусторонние отношения вида “один ко многим” весьма распространены. Следующий пример показывает их реализацию на примере классов __Product__ и __Feature__:

*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="Product">  
        <one-to-many field="features" target-entity="Feature" mapped-by="product" />  
    </entity>  
    <entity name="Feature">  
        <many-to-one field="product" target-entity="Product" inversed-by="features">  
            <join-column name="product_id" referenced-column-name="id" />  
        </many-to-one>  
    </entity>  
</doctrine-mapping>
----
Обратите внимание, что использовать аннотацию__ @JoinColumn__ здесь не обязательно, т.к. значение по умолчанию дадут то же результат.

Итоговая схема __MySQL__ будет выглядеть так:
[source, sql]
----
CREATE TABLE Product (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE Feature (  
    id INT AUTO_INCREMENT NOT NULL,  
    product_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE Feature ADD FOREIGN KEY (product_id) REFERENCES Product(id);
----

=== Отношения “один ко многим” со ссылкой на себя

Пример показывает как настроить иерархию объектов Category с помощью отношения, ссылающегося на само себя. Этот подход позволяет реализовать иерархию категорий, в терминах БД называемой “списком смежных вершин”.

*PHP*
[source, php]
----
<?php
  
/** @Entity */  
class Category  
{  
    // ...  
    /**  
     * @OneToMany(targetEntity="Category", mappedBy="parent")  
     */  
    private $children;  

    /**  
     * @ManyToOne(targetEntity="Category", inversedBy="children")  
     * @JoinColumn(name="parent_id", referencedColumnName="id")  
     */  
    private $parent;  
    // ...  

    public function __construct() {  
        $this->children = new \Doctrine\Common\Collections\ArrayCollection();  
    }  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="Category">  
        <one-to-many field="children" target-entity="Category" mapped-by="parent" />  
        <many-to-one field="parent" target-entity="Category" inversed-by="children" />  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
Category:  
    type: entity  
    oneToMany:  
        children:  
            targetEntity: Category  
            mappedBy: parent  
    manyToOne:  
        parent:  
            targetEntity: Category  
            inversedBy: children
----
Обратите внимание, что использовать аннотацию __@JoinColumn__ здесь не обязательно, т.к. значение по умолчанию дадут то же результат.

Итоговая схема __MySQL__ будет выглядеть так:
[source, sql]
----
CREATE TABLE Category (  
    id INT AUTO_INCREMENT NOT NULL,  
    parent_id INT DEFAULT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE Category ADD FOREIGN KEY (parent_id) REFERENCES Category(id);
----

=== Отношения “многие ко многим”, односторонние

В реальных преложениях отношения типа “многие ко многим” встречаются реже. Следующий пример показывает как они определяются на примере сущностей __User__ и __Group__:

*PHP*
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToMany(targetEntity="Group")  
     * @JoinTable(name="users_groups",  
     * joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},  
     * inverseJoinColumns={@JoinColumn(name="group_id", referencedColumnName="id")}  
     * )  
     */  
    private $groups;  

    // ...  

    public function __construct() {  
        $this->groups = new \Doctrine\Common\Collections\ArrayCollection();  
    }  
}  

/** @Entity */  
class Group  
{  
    // ...  
}
----
*XML*
[source, XML]
----
<doctrine-mapping>  
    <entity name="User">  
        <many-to-many field="groups" target-entity="Group">  
            <join-table name="users_groups">  
                <join-columns>  
                    <join-column name="user_id" referenced-column-name="id" />  
                </join-columns>  
                  
                    <join-column name="group_id" referenced-column-name="id" />  
                  
            </join-table>  
        </many-to-many>  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToMany:  
        groups:  
            targetEntity: Group  
            joinTable:  
                name: users_groups  
                joinColumns:  
                    user_id:  
                        referencedColumnName: id  
                inverseJoinColumns:  
                    group_id:  
                        referencedColumnName: id
----
Итоговая схема MySQL будет выглядеть так:
[source, sql]
----
CREATE TABLE USER (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE users_groups (  
    user_id INT NOT NULL,  
    group_id INT NOT NULL,  
    PRIMARY KEY(user_id, group_id)  
) ENGINE = InnoDB;  

CREATE TABLE GROUP (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

ALTER TABLE users_groups ADD FOREIGN KEY (user_id) REFERENCES USER(id);  
ALTER TABLE users_groups ADD FOREIGN KEY (group_id) REFERENCES GROUP(id);
----
> Так почему же такие связи реже встречаются в повседневной жизни? Все дело в том, что часто вам нужно привязать к связи какие-то дополнительные атрибуты, для чего под эту связь потребуется создать отдельный класс (связь__ManyToMany__ это сделать не позволяет, здесь лишь будет создана таблица с двумя столбцами.) И, как следствие, связь “многие ко многим” в явном виде исчезает, а вместо нее появятся уже две связи -- “один ко многим” и “многие к одному”, связывающие между собой три отдельных класса.

=== Отношения “многие ко многим”, двусторонние

Эти отношения аналогичны описанным выше, но они двусторонние:

*PHP*
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToMany(targetEntity="Group", inversedBy="users")  
     * @JoinTable(name="users_groups")  
     */  
    private $groups;  

    public function __construct() {  
        $this->groups = new \Doctrine\Common\Collections\ArrayCollection();  
    }  

    // ...  
}  

/** @Entity */  
class Group  
{  
    // ...  
    /**  
     * @ManyToMany(targetEntity="User", mappedBy="groups")  
     */  
    private $users;  

    public function __construct() {  
        $this->users = new \Doctrine\Common\Collections\ArrayCollection();  
    }  

    // ...  
}
----
*XML*  
[source, XML]
----
<doctrine-mapping>  
    <entity name="User">  
        <many-to-many field="groups" inversed-by="users">  
            <join-table name="users_groups">  
                <join-columns>  
                    <join-column name="user_id" referenced-column-name="id" />  
                </join-columns>  
                  
                    <join-column name="group_id" referenced-column-name="id" />  
                  
            </join-table>  
        </many-to-many>  
    </entity>  

    <entity name="Group">  
        <many-to-many field="users" mapped-by="groups" />  
    </entity>  
</doctrine-mapping>
----
*YAML*
[source, YAML]
----
User:  
    type: entity  
    manyToMany:  
        groups:  
            targetEntity: Group  
            inversedBy: users  
            joinTable:  
                name: users_groups  
                joinColumns:  
                    user_id:  
                        referencedColumnName: id  
                inverseJoinColumns:  
                    group_id:  
                        referencedColumnName: id  

Group:  
    type: entity  
    manyToMany:  
        users:  
            targetEntity: User  
            mappedBy: groups
----
Итоговая схема базы данных будет такая же как в предыдущем примере для односторонней связи.

===== Picking Owning and Inverse Side

Для связей “многие ко многим” можно указать какая сущность представляет прямую, а какая обратную сторону связи. Чтобы вам как разработчкику было проще определиться с тем, какая из сущностей больше подходит на роль прямой стороны связи, используйте следующее правило. Просто ответьте на вопрос, какая из сущностей отвечает за управление соединением, и это и будет прямая сторона.

Для примера возьмем две сущности: __Article__ (статья) и __Tag__ (тег). Всякий раз, когда вам нужно связать эти две сущности, в большинстве случаев именно __Article__ будет отвечать за эту связь. И всякий раз при создании новой статьи, вам нужно буде соединить ее с существующими или новыми тегами. HTML-форма, отвечающая за создание статей вероятно так и работает, позволяя непосредственно указывать теги. Вот почему в качестве прямой стороны нужно выбрать __Article__, ваш код в этом случае будет более понятен, т.к. вы создаете модель в __Doctrine__ в соответствии с тем, как эта связь функционирует в реальной жизни:
[source, php]
----
<?php
  
class Article  
{  
    private $tags;  

    public function addTag(Tag $tag)  
    {  
        $tag->addArticle($this); // synchronously updating inverse side  
        $this->tags[] = $tag;  
    }  
}  

class Tag  
{  
    private $articles;  

    public function addArticle(Article $article)  
    {  
       $this->articles[] = $article;  
    }  
}
----
Это позволит разместить механизм добавления тегов на Article-стороне связи:
[source, php]
----
<?php
  
$article = new Article();  
$article->addTag($tagA);  
$article->addTag($tagB);
----

===  Отношения “многие ко многим” со ссылкой на себя

Да, они могу ссылаться на сами себя. Типичный сценарий выглядит так: у пользователя __User__ есть друзья, при этом целевая сущность этого отношения это тоже __User__, таким образом имеет место ссылка на самого себя. В этом примере используется двусторонняя связь: у __User__ есть поле __$friendsWithMe__ и поле __$myFriends__.
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToMany(targetEntity="User", mappedBy="myFriends")  
     */  
    private $friendsWithMe;  

    /**  
     * @ManyToMany(targetEntity="User", inversedBy="friendsWithMe")  
     * @JoinTable(name="friends",  
     * joinColumns={@JoinColumn(name="user_id", referencedColumnName="id")},  
     * inverseJoinColumns={@JoinColumn(name="friend_user_id", referencedColumnName="id")}  
     * )  
     */  
    private $myFriends;  

    public function __construct() {  
        $this->friendsWithMe = new \Doctrine\Common\Collections\ArrayCollection();  
        $this->myFriends = new \Doctrine\Common\Collections\ArrayCollection();  
    }  

    // ...  
}
----
Схема БД:

[source, sql]
----
CREATE TABLE USER (  
    id INT AUTO_INCREMENT NOT NULL,  
    PRIMARY KEY(id)  
) ENGINE = InnoDB;  

CREATE TABLE friends (  
    user_id INT NOT NULL,  
    friend_user_id INT NOT NULL,  
    PRIMARY KEY(user_id, friend_user_id)  
) ENGINE = InnoDB;  

ALTER TABLE friends ADD FOREIGN KEY (user_id) REFERENCES USER(id);  
ALTER TABLE friends ADD FOREIGN KEY (friend_user_id) REFERENCES USER(id);
----

=== Сортировка коллекций в связях “To-Many”

Во многих случаях при запросе сущности из БД вам нужно получать коллекции в уже отсортированном виде. Чтобы сделать это нужно определить для коллекции аннотацию __@OrderBy__. В этой аннотации указывается специальное DQL-выражение, которое будет добавляться ко всем запросам к этой коллекции. Описать __@OrderBy__ для аннотаций __@OneToMany__ или __@ManyToMany__можно так:
[source, php]
----
<?php
  
/** @Entity */  
class User  
{  
    // ...  

    /**  
     * @ManyToMany(targetEntity="Group")  
     * @OrderBy({"name" = "ASC"})  
     */  
    private $groups;  
}
----
DQL должен состоять только из “чистых” имен полей без кавычек, а также опционального параметра ASC/DESC. Если нужна сортировка по нескольким полям, они разделяются запятой. Имена столбцов в этом выражении должны существовать в классе__targetEntity__, который описывается в аннотациях __@ManyToMany__ и __@OneToMany__.

Семантику использования этой функции можно описать так:

*   __@OrderBy__ выступает в роли неявного выражения __ORDER BY__, который будет явно добавляться к запросу при выборке набора.
*   Все такие коллекции всегда будут загружаться уже упорядоченными.
*   Чтоб сильно не влиять на работу БД этот неявный __ORDER BY__ добавляется к запросу только если коллекция выбирается явно с подсоединением (fetch joined).

Для вышеприведенного примера следующий DQL-запрос не будет добавлять __ORDER BY__, потому что сущность **g** здесь не присоединяется к запросу явно:

[source, sql]
----
SELECT u FROM USER u JOIN u.groups g WHERE SIZE(g) > 10
----
Однако следующий пример:
[source, sql]
----
SELECT u, g FROM USER u JOIN u.groups g WHERE u.id = 10
----
Будет автоматически переписан в:
[source, sql]
----
SELECT u, g FROM USER u JOIN u.groups g WHERE u.id = 10 ORDER BY g.name ASC
----
И поменять порядок, явно указав его в DQL, нельзя:
[source, sql]
----
SELECT u, g FROM USER u JOIN u.groups g WHERE u.id = 10 ORDER BY g.name DESC
----
Это будет автоматически переписано в:
[source, sql]
----
SELECT u, g FROM USER u JOIN u.groups g WHERE u.id = 10 ORDER BY g.name DESC, g.name ASC
----
